<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NTU Racing Homework 2023: ROS2_Tutorial_Review</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NTU Racing Homework 2023
   &#160;<span id="projectnumber">v0.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">ROS2_Tutorial_Review </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>There's a typo in the docker image file 'ros2_host'</p>
<p>After the configuration of the docker, I started going through the tutorial.</p>
<h1><a class="anchor" id="autotoc_md134"></a>
Beginners: CLI Tools</h1>
<h2><a class="anchor" id="autotoc_md135"></a>
Using turtlesim, ros2, and rqt</h2>
<h3><a class="anchor" id="autotoc_md136"></a>
turtlesim</h3>
<p>Turtlesim is a simulator illustrating the functionality of ROS2 on a robot, which is helpful for me to learn ROS2. To install it, run this inside the container: </p><div class="fragment"><div class="line">sudo apt update</div>
<div class="line">sudo apt install ros-humble-turtlesim</div>
</div><!-- fragment --><p> (ps, the sudo password should be <code>docker</code> according to <a href="https://github.com/NTURacingTeam/docker">NTURacingTeam/docker</a>)</p>
<p>The package is installed: </p><div class="fragment"><div class="line">docker@ros2:~$ ros2 pkg executables turtlesim</div>
<div class="line">turtlesim draw_square</div>
<div class="line">turtlesim mimic</div>
<div class="line">turtlesim turtle_teleop_key</div>
<div class="line">turtlesim turtlesim_node</div>
</div><!-- fragment --><p>Then, start the simulator. </p><div class="fragment"><div class="line">ros2 run turtlesim turtlesim_node</div>
</div><!-- fragment --><p> <img src="/ntu_racing_hw/ros2_setup/pictures/Screenshot%202023-08-13%20085447.png" alt="" class="inline"/></p>
<p>We can now use the turtlesim. <img src="/ntu_racing_hw/ros2_setup/pictures/Screenshot%202023-08-13%20142611.png" alt="" class="inline"/></p>
<h3><a class="anchor" id="autotoc_md137"></a>
rqt</h3>
<p>According to ROSWiki, the introduction to rqt is described as following: </p><blockquote class="doxtable">
<p>rqt is a software framework of ROS that implements the various GUI tools in the form of plugins. One can run all the existing GUI tools as dockable windows within rqt! The tools can still run in a traditional standalone method, but rqt makes it easier to manage all the various windows on the screen at one moment. </p>
</blockquote>
<p>We also install that in our container by <code>sudo apt install ~nros-humble-rqt*</code>. <img src="/ntu_racing_hw/ros2_setup/pictures/Screenshot%202023-08-13%20095046.png" alt="" class="inline"/></p>
<p>Now, I started to use the rqt following the tutorial. Note that, the turtlesim node should be running to reproduce what is shown on the tutorial. The turtlesim is a dockable window that is referred to as a plugin.</p>
<p>Spawn the second turtle <br  />
 <img src="/ntu_racing_hw/ros2_setup/pictures/Screenshot%202023-08-19%20061022.png" alt="" class="inline"/></p>
<p>Set pen of turtle1 <br  />
 <img src="/ntu_racing_hw/ros2_setup/pictures/Screenshot%202023-08-19%20061503.png" alt="" class="inline"/></p>
<p>Remapping the topic <br  />
 The topic is the edge between nodes. Since by default, the command would build the teleop_key to turtle1. So we need to remap the topic between the teleop_key to turtle2. </p><div class="fragment"><div class="line">ros2 run turtlesim turtle_teleop_key --ros-args --remap turtle1/cmd_vel:=turtle2/cmd_vel</div>
</div><!-- fragment --><p> Turtle2 has moved successfully <br  />
 <img src="/ntu_racing_hw/ros2_setup/pictures/Screenshot%202023-08-19%20063319.png" alt="" class="inline"/></p>
<h2><a class="anchor" id="autotoc_md138"></a>
Nodes</h2>
<p>Control a modular function. Nodes can communicate with each other via:</p><ol type="1">
<li>topics</li>
<li>services</li>
<li>actions</li>
<li>parameters</li>
</ol>
<p>This is how to run an executable in ros2 </p><div class="fragment"><div class="line">ros2 run &lt;package_name&gt; &lt;executable_name&gt;</div>
</div><!-- fragment --><p> The previous examples have shown that <code>turtlesim</code> is the package name, and <code>trutlesim_node</code> is the executable launched.</p>
<p>To check what node is currently running, command <code>ros2 node list</code>. This is the result after launching the turtlesim node and the teleop_key node: </p><div class="fragment"><div class="line">docker@ros2:~$ ros2 node list</div>
<div class="line">/teleop_turtle</div>
<div class="line">/turtlesim</div>
</div><!-- fragment --><p> To check out the information of one node, command <code>ros2 node info &lt;node_name&gt;</code>. This is the result after launching the turtlesim node and checking out its information. </p><div class="fragment"><div class="line">docker@ros2:~$ ros2 node info /turtlesim</div>
<div class="line">/turtlesim</div>
<div class="line">  Subscribers:</div>
<div class="line">    /parameter_events: rcl_interfaces/msg/ParameterEvent</div>
<div class="line">    /turtle1/cmd_vel: geometry_msgs/msg/Twist</div>
<div class="line">  Publishers:</div>
<div class="line">    /parameter_events: rcl_interfaces/msg/ParameterEvent</div>
<div class="line">    /rosout: rcl_interfaces/msg/Log</div>
<div class="line">    /turtle1/color_sensor: turtlesim/msg/Color</div>
<div class="line">    /turtle1/pose: turtlesim/msg/Pose</div>
<div class="line">  Service Servers:</div>
<div class="line">    /clear: std_srvs/srv/Empty</div>
<div class="line">    /kill: turtlesim/srv/Kill</div>
<div class="line">    /reset: std_srvs/srv/Empty</div>
<div class="line">    /spawn: turtlesim/srv/Spawn</div>
<div class="line">    /turtle1/set_pen: turtlesim/srv/SetPen</div>
<div class="line">    /turtle1/teleport_absolute: turtlesim/srv/TeleportAbsolute</div>
<div class="line">    /turtle1/teleport_relative: turtlesim/srv/TeleportRelative</div>
<div class="line">    /turtlesim/describe_parameters: rcl_interfaces/srv/DescribeParameters</div>
<div class="line">    /turtlesim/get_parameter_types: rcl_interfaces/srv/GetParameterTypes</div>
<div class="line">    /turtlesim/get_parameters: rcl_interfaces/srv/GetParameters</div>
<div class="line">    /turtlesim/list_parameters: rcl_interfaces/srv/ListParameters</div>
<div class="line">    /turtlesim/set_parameters: rcl_interfaces/srv/SetParameters</div>
<div class="line">    /turtlesim/set_parameters_atomically: rcl_interfaces/srv/SetParametersAtomically</div>
<div class="line">  Service Clients:</div>
<div class="line"> </div>
<div class="line">  Action Servers:</div>
<div class="line">    /turtle1/rotate_absolute: turtlesim/action/RotateAbsolute</div>
<div class="line">  Action Clients:</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md139"></a>
Topics</h2>
<p>To visualize the graph of the ros2, use <code>rqt_graph</code>. Here's the result: <img src="/ntu_racing_hw/ros2_setup/pictures/Screenshot%202023-08-19%20090815.png" alt="" class="inline"/></p>
<p>To check what node is currently running, command <code>ros2 topic list -t</code>. This is the result after launching the turtlesim node and the teleop_key node: </p><div class="fragment"><div class="line">docker@ros2:~$ ros2 topic list -t</div>
<div class="line">/parameter_events [rcl_interfaces/msg/ParameterEvent]</div>
<div class="line">/rosout [rcl_interfaces/msg/Log]</div>
<div class="line">/turtle1/cmd_vel [geometry_msgs/msg/Twist]</div>
<div class="line">/turtle1/color_sensor [turtlesim/msg/Color]</div>
<div class="line">/turtle1/pose [turtlesim/msg/Pose]</div>
</div><!-- fragment --><p>To see the data being published on a topic, command <code>ros2 topic echo &lt;topic_name&gt;</code>. Check out the data on the topic "/turtle1/cmd_vel", and here's the result: (I pressed the right arrow then the up arrow to the teleop_turtle console, so we can tell that the turtle would first recieve an rotation command then a forward-moving command) </p><div class="fragment"><div class="line">linear:</div>
<div class="line">  x: 0.0</div>
<div class="line">  y: 0.0</div>
<div class="line">  z: 0.0</div>
<div class="line">angular:</div>
<div class="line">  x: 0.0</div>
<div class="line">  y: 0.0</div>
<div class="line">  z: -2.0</div>
<div class="line">---</div>
<div class="line">linear:</div>
<div class="line">  x: 2.0</div>
<div class="line">  y: 0.0</div>
<div class="line">  z: 0.0</div>
<div class="line">angular:</div>
<div class="line">  x: 0.0</div>
<div class="line">  y: 0.0</div>
<div class="line">  z: 0.0</div>
<div class="line">---</div>
</div><!-- fragment --><p>Also we can observe that the echo command is functioning with rqt_graph visualization. <br  />
 <img src="/ntu_racing_hw/ros2_setup/pictures/Screenshot%202023-08-19%20094311.png" alt="" class="inline"/></p>
<p>To check out the topic info, use <code>ros2 topic info &lt;topic_name&gt;</code>. Here's the result: </p><div class="fragment"><div class="line">docker@ros2:~ros2 topic info /turtle1/cmd_vel</div>
<div class="line">Type: geometry_msgs/msg/Twist</div>
<div class="line">Publisher count: 1</div>
<div class="line">Subscription count: 1</div>
</div><!-- fragment --><p> (Every topic has publishers and subscriptions as inputs and outputs, with nodes at its both ends)</p>
<p>What is the <code>Type</code> property? It shows that the topic has the type Twist, which is in the msg file inside the geometry_msgs package. The command <code>ros2 interface show geometry_msgs/msg/Twist</code> gives us </p><div class="fragment"><div class="line"># This expresses velocity in free space broken into its linear and angular parts.</div>
<div class="line"> </div>
<div class="line">    Vector3  linear</div>
<div class="line">            float64 x</div>
<div class="line">            float64 y</div>
<div class="line">            float64 z</div>
<div class="line">    Vector3  angular</div>
<div class="line">            float64 x</div>
<div class="line">            float64 y</div>
<div class="line">            float64 z</div>
</div><!-- fragment --><p> The word interface could be related to the java term interface.</p>
<p>To publish data onto a topic, use <code>ros2 topic pub &lt;topic_name&gt; &lt;msg_type&gt; '&lt;args&gt;'</code>. The result is: </p><div class="fragment"><div class="line">docker@ros2:~$ ros2 topic pub --once /turtle1/cmd_vel geometry_msgs/msg/Twist &quot;{linear: {x: 2.0, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 1.8}}&quot;</div>
<div class="line">publisher: beginning loop</div>
<div class="line">publishing #1: geometry_msgs.msg.Twist(linear=geometry_msgs.msg.Vector3(x=2.0, y=0.0, z=0.0), angular=geometry_msgs.msg.Vector3(x=0.0, y=0.0, z=1.8))</div>
</div><!-- fragment --><p> <img src="/ntu_racing_hw/ros2_setup/pictures/Screenshot%202023-08-19%20101303.png" alt="" class="inline"/> Instead of using the <code>teleop_key</code> node to publish controlling data, we use the <code>ros2 topic pub</code> command node to control that turtle by publishing the arguments to that specific topic.</p>
<p>The <code>--once</code> option tells the node to publish once then terminate.</p>
<p>We can make the trutle running in a circle with <code>ros2 topic pub --rate 1 /turtle1/cmd_vel geometry_msgs/msg/Twist "{linear: {x: 2.0, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 1.8}}"</code>, where <code>--rate 1</code> option means to publish such data under 1 Hz frequency. <br  />
 <img src="/ntu_racing_hw/ros2_setup/pictures/Screenshot%202023-08-19%20101806.png" alt="" class="inline"/></p>
<p>With the publishing node(/_ros2cli_805), and the echo node(/_ros2cli_877), the graph shoud look like this: <br  />
 <img src="/ntu_racing_hw/ros2_setup/pictures/Screenshot%202023-08-19%20103133.png" alt="" class="inline"/></p>
<p>To view the rate at which data is published, use <code>ros2 topic hz &lt;topic_name&gt;</code>. Recalled that we use the pub command to publish data onto topic <code>/turtle1/cmd_vel</code> with rate 1. So that the result should look like this: </p><div class="fragment"><div class="line">docker@ros2:~$ ros2 topic hz /turtle1/cmd_vel</div>
<div class="line">average rate: 1.000</div>
<div class="line">        min: 0.999s max: 1.000s std dev: 0.00057s window: 3</div>
<div class="line">average rate: 1.000</div>
<div class="line">        min: 0.999s max: 1.000s std dev: 0.00056s window: 4</div>
<div class="line">average rate: 1.000</div>
<div class="line">        min: 0.999s max: 1.000s std dev: 0.00053s window: 5</div>
<div class="line">.</div>
<div class="line">.</div>
<div class="line">.</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md140"></a>
Services</h2>
<p>Nodes could also communicate through services as well. It's based on a call-and-response model.</p>
<p>To show the service list, use <code>ros2 service list</code>. Here's the result </p><div class="fragment"><div class="line">docker@ros2:~$ ros2 service list</div>
<div class="line">/clear</div>
<div class="line">/kill</div>
<div class="line">/reset</div>
<div class="line">/spawn</div>
<div class="line">/teleop_turtle/describe_parameters</div>
<div class="line">/teleop_turtle/get_parameter_types</div>
<div class="line">/teleop_turtle/get_parameters</div>
<div class="line">/teleop_turtle/list_parameters</div>
<div class="line">/teleop_turtle/set_parameters</div>
<div class="line">/teleop_turtle/set_parameters_atomically</div>
<div class="line">/turtle1/set_pen</div>
<div class="line">/turtle1/teleport_absolute</div>
<div class="line">/turtle1/teleport_relative</div>
<div class="line">/turtlesim/describe_parameters</div>
<div class="line">/turtlesim/get_parameter_types</div>
<div class="line">/turtlesim/get_parameters</div>
<div class="line">/turtlesim/list_parameters</div>
<div class="line">/turtlesim/set_parameters</div>
<div class="line">/turtlesim/set_parameters_atomically</div>
</div><!-- fragment --><p> Recall the part about rqt, that service drop list is shown here. (ps, the parameters will be in the next part)</p>
<p>I realized that recording the tutorial step by step is time-consuming. From now on, I'll only collect those worth noting.</p>
<h2><a class="anchor" id="autotoc_md141"></a>
Services</h2>
<p>Using <code>ros2 interface show &lt;type_name&gt;</code> can show the information about that type. The "---" separates the request structure (above) from the response structure (below). </p><div class="fragment"><div class="line">ros2 interface show turtlesim/srv/Spawn</div>
<div class="line"> </div>
<div class="line">// then return</div>
<div class="line"> </div>
<div class="line">float32 x</div>
<div class="line">float32 y</div>
<div class="line">float32 theta</div>
<div class="line">string name # Optional.  A unique name will be created and returned if this is empty</div>
<div class="line">---</div>
<div class="line">string name</div>
</div><!-- fragment --><p>Another example: </p><div class="fragment"><div class="line">ros2 service call /spawn turtlesim/srv/Spawn &quot;{x: 2, y: 2, theta: 0.2, name: &#39;&#39;}&quot;</div>
</div><!-- fragment --><p> It can spawn a turtle using the service. But what's the deifferene between such service call and the publishing call? Quoted from the official website: </p><blockquote class="doxtable">
<p>Nodes can communicate using services in ROS 2. Unlike a topic - a one way communication pattern where a node publishes information that can be consumed by one or more subscribers - a service is a request/response pattern where a client makes a request to a node providing the service and the service processes the request and generates a response. </p>
</blockquote>
<p><img src="/ntu_racing_hw/ros2_setup/pictures/Screenshot%202023-08-19%20112939.png" alt="" class="inline"/></p>
<h2><a class="anchor" id="autotoc_md142"></a>
Parameters</h2>
<blockquote class="doxtable">
<p>A parameter is a configuration value of a node. You can think of parameters as node settings. </p>
</blockquote>
<p>Change the background color of turtle sim: </p><div class="fragment"><div class="line">docker@ros2:~$ ros2 param set /turtlesim background_r 150</div>
<div class="line">Set parameter successful</div>
</div><!-- fragment --><p> <img src="/ntu_racing_hw/ros2_setup/pictures/Screenshot%202023-08-19%20115758.png" alt="" class="inline"/></p>
<div class="fragment"><div class="line">&gt; Dumping parameters comes in handy if you want to reload the node with the same parameters in the future.</div>
<div class="line">To load it from the future, use ```ros2 param load &lt;name&gt; &lt;file&gt;</div>
</div><!-- fragment --><p> If you want to load the parameters while starting a node -&gt; <code>ros2 run &lt;package_name&gt; &lt;executable_name&gt; --ros-args --params-file &lt;file_name&gt;</code></p>
<h2><a class="anchor" id="autotoc_md143"></a>
Actions</h2>
<blockquote class="doxtable">
<p>They consist of three parts: a goal, feedback, and a result. </p>
</blockquote>
<p><img src="/ntu_racing_hw/ros2_setup/pictures/Screenshot%202023-08-20%20131104.png" alt="" class="inline"/></p>
<p>To check the information of one action, use: </p><div class="fragment"><div class="line">To see the action list of a node, use:</div>
<div class="line">```ros2 action list -t```, -t is for showing the action type.</div>
<div class="line"> </div>
<div class="line">We also can use interface show to acknowledge the action data type within. </div>
<div class="line">&gt;The section of this message above the first --- is the structure (data type and name) of the goal request. The next section is the structure of the result. The last section is the structure of the feedback.</div>
<div class="line"> </div>
<div class="line">To send a goal of an action: ```ros2 action send_goal &lt;action_name&gt; &lt;action_type&gt; &lt;values&gt;</div>
</div><!-- fragment --><blockquote class="doxtable">
<p>A robot system would likely use actions for navigation. An action goal could tell a robot to travel to a position. While the robot navigates to the position, it can send updates along the way (i.e. feedback), and then a final result message once it’s reached its destination. </p>
</blockquote>
<h2><a class="anchor" id="autotoc_md144"></a>
rqt_console</h2>
<p>&gt;Fatal messages indicate the system is going to terminate to try to protect itself from detriment.</p>
<p>&gt;Error messages indicate significant issues that won’t necessarily damage the system, but are preventing it from functioning properly.</p>
<p>&gt;Warn messages indicate unexpected activity or non-ideal results that might represent a deeper issue, but don’t harm functionality outright.</p>
<p>&gt;Info messages indicate event and status updates that serve as a visual verification that the system is running as expected.</p>
<p>&gt;Debug messages detail the entire step-by-step process of the system execution.</p>
<p>These are the 5 severity levels of messages. The severity filter would filter out those with less severity level than the chosen option.</p>
<p>To set the severity level: </p><div class="fragment"><div class="line">ros2 run turtlesim turtlesim_node --ros-args --log-level WARN</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md145"></a>
Record Topics</h2>
<p>To record topic data: </p><div class="fragment"><div class="line">ros2 bag record &lt;topic_name&gt;</div>
</div><!-- fragment --><p> It should create a directory <code>rosbag2_year_month_day-hour_minute_second</code> with a file <code>metadata.yaml</code> that records the data.</p>
<p>To record multiple topics, just list them out. -o option is for naming: </p><div class="fragment"><div class="line">ros2 bag record -o subset /turtle1/cmd_vel /turtle1/pose</div>
</div><!-- fragment --><p>To check the bag info </p><div class="fragment"><div class="line">ros2 bag info &lt;bag_file_name&gt;</div>
</div><!-- fragment --><p>To replay what just recorded, use: </p><div class="fragment"><div class="line">ros2 bag play &lt;bag_file_name&gt;</div>
</div><!-- fragment --><p>&gt;Because the subset file recorded the /turtle1/pose topic, the ros2 bag play command won’t quit for as long as you had turtlesim running, even if you weren’t moving.This is because as long as the /turtlesim node is active, it publishes data on the /turtle1/pose topic at regular intervals. You may have noticed in the ros2 bag info example result above that the /turtle1/cmd_vel topic’s Count information was only 9; that’s how many times we pressed the arrow keys while recording.Notice that /turtle1/pose has a Count value of over 3000; while we were recording, data was published on that topic 3000 times.To get an idea of how often position data is published, you can run the command:</p>
<h1><a class="anchor" id="autotoc_md146"></a>
Beginners: Client Libraries</h1>
<h2><a class="anchor" id="autotoc_md147"></a>
Creating a wrokspace</h2>
<h3><a class="anchor" id="autotoc_md148"></a>
Resolve dependencies</h3>
<p>&gt;Before building the workspace, you need to resolve the package dependencies. You may have all the dependencies already, but best practice is to check for dependencies every time you clone. You wouldn’t want a build to fail after a long wait only to realize that you have missing dependencies.</p>
<p>To check the dependencies: </p><div class="fragment"><div class="line">rosdep install -i --from-path src --rosdistro humble -y</div>
</div><!-- fragment --><p>&gt;Packages declare their dependencies in the package.xml file</p>
<h3><a class="anchor" id="autotoc_md149"></a>
Source the overlay</h3>
<p>&gt;In the new terminal, source your main ROS 2 environment as the “underlay”, so you can build the overlay “on top of” it: </p><div class="fragment"><div class="line"># source the underlay</div>
<div class="line">source /opt/ros/humble/setup.bash</div>
<div class="line">cd ~/ws/src/ros2_ws</div>
<div class="line"># source the overlay</div>
<div class="line">source install/local_setup.bash</div>
</div><!-- fragment --><p> (The source command is just basically executing the setup file that build the ROS2 environment and the overlay package)</p>
<p>or just run </p><div class="fragment"><div class="line">source install/steup.bash</div>
<div class="line"># it sources both ROS2 environment as underlay and the packages as overlay</div>
</div><!-- fragment --><p>Then run the turtlesim. To tell the concept of overlay and underlay, we should know whether the turtlesim we ran is from the package or from the original installation. To achieve that, we can modify the overlay.</p>
<p>This is the result after modifying the source file and <code>colcon build</code> it again.</p>
<p><img src="/ntu_racing_hw/ros2_setup/pictures/Screenshot%202023-08-26%20205304.png" alt="" class="inline"/></p>
<blockquote class="doxtable">
<p>modifications in the overlay did not actually affect anything in the underlay </p>
</blockquote>
<p>&gt;In this tutorial, you sourced your main ROS 2 distro install as your underlay, and created an overlay by cloning and building packages in a new workspace. The overlay gets prepended to the path, and takes precedence over the underlay, as you saw with your modified turtlesim. Using overlays is recommended for working on a small number of packages, so you don’t have to put everything in the same workspace and rebuild a huge workspace on every iteration.</p>
<h2><a class="anchor" id="autotoc_md150"></a>
Creating a package</h2>
<blockquote class="doxtable">
<p>A package is an organizational unit for your ROS 2 code. </p>
</blockquote>
<blockquote class="doxtable">
<p>Package creation in ROS 2 uses ament as its build system and colcon as its build tool. You can create a package using either CMake or Python, which are officially supported </p>
</blockquote>
<p>In a CMake package directory, it should include:</p><ol type="1">
<li><code>CMakeLists.txt</code> file that describes how to build the code within the package</li>
<li><code>include/&lt;package_name&gt;</code> directory containing the public headers for the package</li>
<li><code>package.xml</code> file containing meta information about the package</li>
<li><code>src</code> directory containing the source code for the package</li>
</ol>
<p>To create a new package in ros2: </p><div class="fragment"><div class="line">ros2 pkg create --build-type ament_cmake &lt;package_name&gt;</div>
</div><!-- fragment --><div class="fragment"></div><!-- fragment --><p> colcon build &ndash;packages-select my_package </p><div class="fragment"><div class="line">It&#39;s important to run ```source install/local_setup.bash``` to add the workspace to the path, inorder to use the package executables.</div>
<div class="line"> </div>
<div class="line">We should also customize the package.xml, inside the description tag, maintainer tag, and licenses tag.</div>
<div class="line">&gt;Below the license tag, you will see some tag names ending with _depend. This is where your package.xml would list its dependencies on other packages, for colcon to search for. </div>
<div class="line"> </div>
<div class="line">### C++ publisher and subscriber</div>
<div class="line">**Communicate through topics**</div>
<div class="line"> </div>
<div class="line">To add dependencies, we should let cmake know what headers are needed. To do so, we should modify the ```package.xml``` file and ```CMakeLists.txt``` file, and add dependencies according to the headers included.</div>
</div><!-- fragment --><p> #include "rclcpp/rclcpp.hpp" #include "std_msgs/msg/string.hpp" </p><div class="fragment"></div><!-- fragment --><p> &lt;buildtool_depend&gt;ament_cmake&lt;/buildtool_depend&gt; &lt;depend&gt;rclcpp&lt;/depend&gt; &lt;depend&gt;std_msgs&lt;/depend&gt; </p><div class="fragment"><div class="line">(Note that the dependencies tags should be added after ament_cmake)</div>
</div><!-- fragment --><p> find_package(ament_cmake REQUIRED) find_package(rclcpp REQUIRED) find_package(std_msgs REQUIRED) </p><div class="fragment"><div class="line">Also in ```CMakeLists.txt```, add this to run the code using ```ros2 run```:</div>
</div><!-- fragment --><p> add_executable(talker src/publisher_member_function.cpp) ament_target_dependencies(talker rclcpp std_msgs) </p><div class="fragment"><div class="line">And add this so that ```ros2 run``` can find the executables:</div>
</div><!-- fragment --><p> install(TARGETS talker DESTINATION lib/${PROJECT_NAME}) </p><div class="fragment"><div class="line">(talker is the executable name)</div>
<div class="line"> </div>
<div class="line">&gt;The main function is exactly the same, except now it spins the MinimalSubscriber node. For the publisher node, spinning meant starting the timer, but for the subscriber it simply means preparing to receive messages whenever they come.</div>
<div class="line"> </div>
<div class="line">Then we also wget the subscriber code. Note that we don&#39;t need to modify the ```package.xml``` file, for the headers needed are the same. But we should modify the ```CMakeLists.txt``` file, for the cmake should capture the code.</div>
</div><!-- fragment --><p>add_executable(listener src/subscriber_member_function.cpp) ament_target_dependencies(listener rclcpp std_msgs)</p>
<p>install(TARGETS talker listener DESTINATION lib/${PROJECT_NAME}) </p><div class="fragment"><div class="line">Then run ```rosdep``` in the root of your workspace (ros2_ws) to check for missing dependencies before building:</div>
</div><!-- fragment --><p> rosdep install -i &ndash;from-path src &ndash;rosdistro humble -y </p><div class="fragment"><div class="line">Then use colcon to build the new package:</div>
</div><!-- fragment --><p> colcon build &ndash;packages-select cpp_pubsub </p><div class="fragment"><div class="line">Also, don&#39;t forget to source that bash inorder to find the executables.</div>
</div><!-- fragment --><p> . install/setup.bash </p><div class="fragment"><div class="line">Then run it: (The package name is ```cpp_pubsub```, and the node(executable) name is ```talker```)</div>
</div><!-- fragment --><p> ros2 run cpp_pubsub talker </p><div class="fragment"><div class="line">### C++ Client and Server</div>
<div class="line">**Communicate through services**</div>
<div class="line">&gt; The structure of the request and response is determined by a ```.srv``` file.</div>
<div class="line">The ```.srv``` file in the following example looks like (defining the data type of the request and response):</div>
</div><!-- fragment --><p> int64 a </p>
<h1><a class="anchor" id="autotoc_md151"></a>
int64 b</h1>
<p>int64 sum </p><div class="fragment"><div class="line">(example_interfaces is the package that includes the .srv file)</div>
<div class="line"> </div>
<div class="line">While creating a package, we can add the dependencies option to create the correct files by default.</div>
</div><!-- fragment --><p> ros2 pkg create &ndash;build-type ament_cmake cpp_srvcli &ndash;dependencies rclcpp example_interfaces </p><div class="fragment"><div class="line">Inside ```CmakeLists.txt```, note that although dependencies are built by the last command, we still need the ```add_executable()``` macro generates an executable so that we can run it through ```ros2 run</div>
</div><!-- fragment --> <div class="fragment"><div class="line">add_executable(server src/add_two_ints_server.cpp)</div>
<div class="line">ament_target_dependencies(server rclcpp example_interfaces)</div>
</div><!-- fragment --> <div class="fragment"><div class="line">install(TARGETS</div>
<div class="line">    server</div>
<div class="line">  DESTINATION lib/${PROJECT_NAME})</div>
</div><!-- fragment --><p> (ps that <code>RCLCPP_INFO</code> is like <code>fprintf</code>)</p>
<p>Also, after finishing the client's code, we should modify the <code>CMakeLists.txt</code> as well. After all, in the root workspace directory, we should check the dependencies by: </p><div class="fragment"><div class="line">rosdep install -i --from-path src --rosdistro humble -y</div>
</div><!-- fragment --><p> Then build it with the following command (don't forget to check the returned message that the colcon build was successful) </p><div class="fragment"><div class="line">colcon build --packages-select cpp_srvcli</div>
</div><!-- fragment --><p> Then, don't forget to source the setup file so that the paths to those executables are added. </p><div class="fragment"><div class="line">source install/setup.bash</div>
</div><!-- fragment --><p>When running, we can notice that the server is continue running no matter there's a client or not. When a client occurs, it recieve the request and return the response after processing.</p>
<h2><a class="anchor" id="autotoc_md152"></a>
Creating custom msg and srv files</h2>
<p>Remember that these types of files define the communication of two nodes in an ros2 graph, aka intefaces. One defines topics, and the other defines services.</p>
<p>Inside <code>Sphere.msg</code>, it uses a message from another message package-<code>geometry_msgs/Point</code>. (In the package geometry_msgs, the msg named Point)</p>
<p>After creating the msg files and srv files, modify <code>CMakeLists.txt</code> and <code>package.xml</code>. </p><div class="fragment"><div class="line">find_package(geometry_msgs REQUIRED)</div>
<div class="line">find_package(rosidl_default_generators REQUIRED)</div>
<div class="line"> </div>
<div class="line">rosidl_generate_interfaces(${PROJECT_NAME}</div>
<div class="line">  &quot;msg/Num.msg&quot;</div>
<div class="line">  &quot;msg/Sphere.msg&quot;</div>
<div class="line">  &quot;srv/AddThreeInts.srv&quot;</div>
<div class="line">  DEPENDENCIES geometry_msgs # Add packages that above messages depend on, in this case geometry_msgs for Sphere.msg</div>
<div class="line">)</div>
</div><!-- fragment --><p> The find_package is understandable. we need the <code>geometry_msgs</code> package, for it's used in the <code>Sphere.msg</code>. We need the <code>rosidl_default_generators</code>, for we need it to generate language-specific code (c++ in this case) from the msg or srv files. (ps rosidl stands for ros interface definition language)</p>
<div class="fragment"><div class="line">&lt;depend&gt;geometry_msgs&lt;/depend&gt; # The dependencies of the package interface it self</div>
<div class="line">&lt;buildtool_depend&gt;rosidl_default_generators&lt;/buildtool_depend&gt; # This is the dependencies of the buildtool</div>
<div class="line">&lt;exec_depend&gt;rosidl_default_runtime&lt;/exec_depend&gt; # this is the dependencies during runtime to use the interfaces</div>
<div class="line">&lt;member_of_group&gt;rosidl_interface_packages&lt;/member_of_group&gt; # this is the the package that my package should be associated with</div>
</div><!-- fragment --><p> &gt;Because the interfaces rely on rosidl_default_generators for generating language-specific code, you need to declare a build tool dependency on it. rosidl_default_runtime is a runtime or execution-stage dependency, needed to be able to use the interfaces later. The rosidl_interface_packages is the name of the dependency group that your package, tutorial_interfaces, should be associated with, declared using the &lt;member_of_group&gt; tag.</p>
<p>Then colcon build, source the setup. Remember that we've check the interfaces before while we learned about topics. Now, we use the <code>ros2 interface show</code> command to see whether our interface is available or not. </p><div class="fragment"><div class="line">ros2 interface show tutorial_interfaces/msg/Num</div>
<div class="line"> </div>
<div class="line"># return</div>
<div class="line">int64 num</div>
</div><!-- fragment --> <div class="fragment"><div class="line">ros2 interface show tutorial_interfaces/msg/Sphere</div>
<div class="line"> </div>
<div class="line">#return</div>
<div class="line">geometry_msgs/Point center</div>
<div class="line">        float64 x</div>
<div class="line">        float64 y</div>
<div class="line">        float64 z</div>
<div class="line">float64 radius</div>
</div><!-- fragment --> <div class="fragment"><div class="line">ros2 interface show tutorial_interfaces/srv/AddThreeInts</div>
<div class="line"> </div>
<div class="line">#return</div>
<div class="line">int64 a</div>
<div class="line">int64 b</div>
<div class="line">int64 c</div>
<div class="line">---</div>
<div class="line">int64 sum</div>
</div><!-- fragment --><p> Now we can test whether we could use these interfaces or not. Use the publisher and subscriber code and modify it. Then add a few lines to <code>CMakeLists.txt</code> and <code>package.xml</code> files to meet the source code. Afterall, build it, then source it. Then in two terminals run the talker and listener separately.</p>
<p>By the way, the tutorial modified the code used in previous ones, but I want to keep the previous version intact so I created the source code inside the <code>tutorial_interfaces</code> package. However, an error occurred while delivering <code>colcon build</code>: </p><div class="fragment"><div class="line">The package &quot;tutorial_interfaces&quot; must not &quot;build_depend&quot; on a package with the same name as this package</div>
<div class="line">The package &quot;tutorial_interfaces&quot; must not &quot;build_export_depend&quot; on a package with the same name as this package  </div>
<div class="line">The package &quot;tutorial_interfaces&quot; must not &quot;exec_depend&quot; on a package with the same name as this package</div>
</div><!-- fragment --><p> So that I created another package <code>cpp_pubsub_interfaces</code> to keep each version clean and healthy. By the way, recall that nested packages are not allowed in ROS2. In this case, self-dependencies is also nested by its child is itself. Also, the changes are about the message type (<code>tutorial_interfaces::msg::Num</code> and <code>std_msgs::msg::String</code>). (ps. tutorial_interfaces should be built before cpp_pubsub_tutorial)</p>
<p>ALso, be careful that the project name in the <code>CMakeLists.txt</code> should also be changed to <code>cpp_pubsub_interfaces</code> as well. Otherwise, <code>$PROJECT_NAME</code> won't match.</p>
<p>Finally, source the setup files, then run <code>ros2 run cpp_pubsub_interfaces talker</code> and <code>ros2 run cpp_pubsub_interfaces listener</code> in two different terminals.</p>
<p>Do the same to the <code>AddThreeInts.srv</code> with client and server. Create a new package, and set up the configuration files, then build those files, then finally, source it then run it. By the way, the newly created package, <code>cpp_srvcli_interfaces</code> also uses the <code>tutorial_interfaces</code> package. Here's the result </p><div class="fragment"><div class="line">docker@ros2:~/ws/src/ros2_ws$ ros2 run cpp_srvcli_interfaces server</div>
<div class="line">[INFO] [1693291703.803293812] [rclcpp]: Ready to add three ints.</div>
<div class="line">[INFO] [1693291714.448700490] [rclcpp]: Incoming request</div>
<div class="line">a: 2 b: 3 c: 1</div>
<div class="line">[INFO] [1693291714.448747191] [rclcpp]: sending back response: [6]</div>
<div class="line">^C[INFO] [1693291717.010731524] [rclcpp]: signal_handler(signum=2)</div>
</div><!-- fragment --> <div class="fragment"><div class="line">docker@ros2:~/ws/src/ros2_ws$ ros2 run cpp_srvcli_interfaces client 2 3 1</div>
<div class="line">[INFO] [1693291714.449219891] [rclcpp]: Sum: 6</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md153"></a>
Implementing custom interfaces</h2>
<blockquote class="doxtable">
<p>Note that it’s possible to set default values for fields within a message definition. </p>
</blockquote>
<p>A package named <code>more_interfaces</code> is created. And these should go to <code>package.xml</code>. </p><div class="fragment"><div class="line">&lt;buildtool_depend&gt;rosidl_default_generators&lt;/buildtool_depend&gt;</div>
<div class="line">&lt;exec_depend&gt;rosidl_default_runtime&lt;/exec_depend&gt;</div>
<div class="line">&lt;member_of_group&gt;rosidl_interface_packages&lt;/member_of_group&gt;</div>
</div><!-- fragment --><p> &gt;Note that at build time, we need <code>rosidl_default_generator</code>s, while at runtime, we only need <code>rosidl_default_runtime</code>.</p>
<p>As for the <code>CMakeLists.txt</code> file, add: </p><div class="fragment"><div class="line">find_package(rosidl_default_generators REQUIRED)</div>
<div class="line"> </div>
<div class="line"># it just lists the messages out inn msg_files</div>
<div class="line">set(msg_files</div>
<div class="line">  &quot;msg/AddressBook.msg&quot;</div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line"># transform the idl into c++ cod</div>
<div class="line">rosidl_generate_interfaces(${PROJECT_NAME}</div>
<div class="line">  ${msg_files}</div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line"># export the message runtime dependency</div>
<div class="line">ament_export_dependencies(rosidl_default_runtime)</div>
</div><!-- fragment --><p> (ps. we can use <code>set</code> like this to list out all our interfaces) </p><div class="fragment"><div class="line">set(msg_files</div>
<div class="line">  &quot;msg/Message1.msg&quot;</div>
<div class="line">  &quot;msg/Message2.msg&quot;</div>
<div class="line">  # etc</div>
<div class="line">  )</div>
<div class="line"> </div>
<div class="line">set(srv_files</div>
<div class="line">  &quot;srv/Service1.srv&quot;</div>
<div class="line">  &quot;srv/Service2.srv&quot;</div>
<div class="line">   # etc</div>
<div class="line">  )</div>
<div class="line"># generate all at once</div>
<div class="line">rosidl_generate_interfaces(${PROJECT_NAME}</div>
<div class="line">  ${msg_files}</div>
<div class="line">  ${srv_files}</div>
<div class="line">)</div>
</div><!-- fragment --><p>There's one thing worth noting is that, it uses a lambda expression in the constructor. I don't understand what it is until I searched on Google. <a href="https://learn.microsoft.com/en-us/cpp/cpp/lambda-expressions-in-cpp?view=msvc-170">Link</a>. </p><div class="fragment"><div class="line">auto publish_msg = [this]() -&gt; void {</div>
<div class="line">        auto message = more_interfaces::msg::AddressBook();</div>
<div class="line"> </div>
<div class="line">        message.first_name = &quot;John&quot;;</div>
<div class="line">        message.last_name = &quot;Doe&quot;;</div>
<div class="line">        message.phone_number = &quot;1234567890&quot;;</div>
<div class="line">        message.phone_type = message.PHONE_TYPE_MOBILE;</div>
<div class="line"> </div>
<div class="line">        std::cout &lt;&lt; &quot;Publishing Contact\nFirst:&quot; &lt;&lt; message.first_name &lt;&lt;</div>
<div class="line">          &quot;  Last:&quot; &lt;&lt; message.last_name &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">        this-&gt;address_book_publisher_-&gt;publish(message);</div>
<div class="line">      };</div>
</div><!-- fragment --><ul>
<li><code>[this]</code>: the captured variable, which is the one in the same locality of this lambda expression which would be used later</li>
<li><code>()</code>: it takes no parameters</li>
<li><code>-&gt; void</code>: it has no return type, it returns nothing</li>
<li><code>{};</code>: the body of the lambda expression</li>
</ul>
<p>Then create a new target for this node: </p><div class="fragment"><div class="line">find_package(rclcpp REQUIRED)</div>
<div class="line"> </div>
<div class="line"># the target is publish_address_book, and it depends on another target called rclcpp</div>
<div class="line">add_executable(publish_address_book src/publish_address_book.cpp)</div>
<div class="line">ament_target_dependencies(publish_address_book rclcpp)</div>
<div class="line"> </div>
<div class="line">install(TARGETS</div>
<div class="line">    publish_address_book</div>
<div class="line">  DESTINATION lib/${PROJECT_NAME})</div>
</div><!-- fragment --><p>I've tried to use interfaces in the same package and failed. This following CMake code can fix that. </p><div class="fragment"><div class="line">rosidl_get_typesupport_target(cpp_typesupport_target</div>
<div class="line">  ${PROJECT_NAME} rosidl_typesupport_cpp)</div>
<div class="line"> </div>
<div class="line">target_link_libraries(publish_address_book &quot;${cpp_typesupport_target}&quot;)</div>
</div><!-- fragment --><p> &gt;This finds the relevant generated C++ code from AddressBook.msg and allows your target to link against it.You may have noticed that this step was not necessary when the interfaces being used were from a different package that was built independently. This CMake code is only required when you want to use interfaces in the same package as the one in which they are defined.</p>
<p>Then, as always, build it, source it, and run it. The result: </p><div class="fragment"><div class="line">docker@ros2:~/ws/src/ros2_ws$ ros2 run more_interfaces publish_address_book</div>
<div class="line">Publishing Contact</div>
<div class="line">First:John  Last:Doe</div>
</div><!-- fragment --> <div class="fragment"><div class="line">docker@ros2:~/ws/src/ros2_ws$ ros2 topic echo /address_book</div>
<div class="line">first_name: John</div>
<div class="line">last_name: Doe</div>
<div class="line">phone_number: &#39;1234567890&#39;</div>
<div class="line">phone_type: 2</div>
<div class="line">---</div>
</div><!-- fragment --><p>&gt;In this tutorial, you tried out different field types for defining interfaces, then built an interface in the same package where it’s being used. You also learned how to use another interface as a field type, as well as the package.xml, CMakeLists.txt, and #include statements necessary for utilizing that feature.</p>
<h2><a class="anchor" id="autotoc_md154"></a>
Using parameters in a class (C++)</h2>
<div class="fragment"><div class="line">ros2 pkg create --build-type ament_cmake cpp_parameters --dependencies rclcpp</div>
</div><!-- fragment --><p> &gt;Because you used the &ndash;dependencies option during package creation, you don’t have to manually add dependencies to package.xml or CMakeLists.txt.</p>
<p>Then examine the code: </p><div class="fragment"><div class="line">class MinimalParam : public rclcpp::Node</div>
<div class="line">{</div>
<div class="line">public:</div>
<div class="line">  MinimalParam()</div>
<div class="line">  : Node(&quot;minimal_param_node&quot;)</div>
<div class="line">  {</div>
<div class="line">    auto param_desc = rcl_interfaces::msg::ParameterDescriptor{};</div>
<div class="line">    param_desc.description = &quot;This parameter is mine!&quot;;</div>
<div class="line">    // Descriptors allow you to specify a text description of the parameter and its constraints, like making it read-only, specifying a range, etc.</div>
<div class="line"> </div>
<div class="line">    this-&gt;declare_parameter(&quot;my_parameter&quot;, &quot;world&quot;, param_desc); // this declare the parameter named my_parameter valued string type &quot;world&quot;</div>
<div class="line"> </div>
<div class="line">    timer_ = this-&gt;create_wall_timer(</div>
<div class="line">      1000ms, std::bind(&amp;MinimalParam::timer_callback, this)); </div>
<div class="line">      // this causes the timer_callback function to be executed every 1000ms</div>
<div class="line">  }</div>
<div class="line">  void timer_callback()</div>
<div class="line">  {</div>
<div class="line">    std::string my_param = this-&gt;get_parameter(&quot;my_parameter&quot;).as_string(); // gets the parameter and stores it in my_param</div>
<div class="line"> </div>
<div class="line">    RCLCPP_INFO(this-&gt;get_logger(), &quot;Hello %s!&quot;, my_param.c_str());</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;rclcpp::Parameter&gt; all_new_parameters{rclcpp::Parameter(&quot;my_parameter&quot;, &quot;world&quot;)};</div>
<div class="line">    this-&gt;set_parameters(all_new_parameters); // this set the parameter my_parameter back to the default value world</div>
<div class="line">    // this ensures it is always reset back to the original</div>
<div class="line">  }</div>
</div><!-- fragment --><p>Then add this to the <code>CMakeLists.txt</code> file </p><div class="fragment"><div class="line">find_package(rclcpp REQUIRED)</div>
<div class="line"> </div>
<div class="line">add_executable(minimal_param_node src/cpp_parameters_node.cpp)</div>
<div class="line">ament_target_dependencies(minimal_param_node rclcpp)</div>
<div class="line"> </div>
<div class="line">install(TARGETS</div>
<div class="line">    minimal_param_node</div>
<div class="line">  DESTINATION lib/${PROJECT_NAME}</div>
<div class="line">)</div>
</div><!-- fragment --><p>Then, check dependencies, build it, source it, and run it. </p><div class="fragment"><div class="line">rosdep install -i --from-path src --rosdistro humble -y</div>
<div class="line">colcon build --packages-select cpp_parameters</div>
<div class="line">source install/setup.bash</div>
<div class="line">ros2 run cpp_parameters minimal_param_node</div>
</div><!-- fragment --><p> After running the node, the terminal shows the default value of the parameter. We can see the parameters </p><div class="fragment"><div class="line">docker@ros2:~$ ros2 param list</div>
<div class="line">/minimal_param_node:</div>
<div class="line">  my_parameter</div>
<div class="line">  qos_overrides./parameter_events.publisher.depth</div>
<div class="line">  qos_overrides./parameter_events.publisher.durability</div>
<div class="line">  qos_overrides./parameter_events.publisher.history</div>
<div class="line">  qos_overrides./parameter_events.publisher.reliability</div>
<div class="line">  use_sim_time</div>
</div><!-- fragment --><p> To change it, use param set, enter this in another terminal: </p><div class="fragment"><div class="line">ros2 param set /minimal_param_node my_parameter earth</div>
</div><!-- fragment --><p> The log info shown in the terminal: </p><div class="fragment"><div class="line">[INFO] [1693707247.202344702] [minimal_param_node]: Hello world!</div>
<div class="line">[INFO] [1693707248.202338617] [minimal_param_node]: Hello earth!</div>
<div class="line">[INFO] [1693707249.202349402] [minimal_param_node]: Hello world!</div>
</div><!-- fragment --><p> However, the parameter would be set back to the default value every callback, so the set value "earth" only shown in one duration.</p>
<p>We can change the parameters via a launch file as well. In the package, create <code>launch/cpp_parameters_launch.py</code> </p><div class="fragment"><div class="line">from launch import LaunchDescription</div>
<div class="line">from launch_ros.actions import Node</div>
<div class="line"> </div>
<div class="line">def generate_launch_description():</div>
<div class="line">    return LaunchDescription([</div>
<div class="line">        Node(</div>
<div class="line">            package=&quot;cpp_parameters&quot;,</div>
<div class="line">            executable=&quot;minimal_param_node&quot;,</div>
<div class="line">            name=&quot;custom_minimal_param_node&quot;,</div>
<div class="line"> </div>
<div class="line">            # we ensure our output is printed in our console.</div>
<div class="line">            output=&quot;screen&quot;,</div>
<div class="line">            emulate_tty=True,</div>
<div class="line"> </div>
<div class="line">            </div>
<div class="line">            parameters=[</div>
<div class="line">                {&quot;my_parameter&quot;: &quot;earth&quot;}</div>
<div class="line">            ]</div>
<div class="line">        )</div>
<div class="line">    ])</div>
</div><!-- fragment --><p> Then, add the launch file to <code>CMakeLists.txt</code> file </p><div class="fragment"><div class="line">install(</div>
<div class="line">  DIRECTORY launch</div>
<div class="line">  DESTINATION share/${PROJECT_NAME}</div>
<div class="line">)</div>
</div><!-- fragment --><p>Then, check it, build it, source it, then run it. </p><div class="fragment"><div class="line">docker@ros2:~/ws/src/ros2_ws$ ros2 launch cpp_parameters cpp_parameters_launch.py</div>
<div class="line">[INFO] [launch]: All log files can be found below /home/docker/.ros/log/2023-09-03-10-31-08-711418-ros2-568</div>
<div class="line">[INFO] [launch]: Default logging verbosity is set to INFO</div>
<div class="line">[INFO] [minimal_param_node-1]: process started with pid [569]</div>
<div class="line">[minimal_param_node-1] [INFO] [1693708270.685820721] [custom_minimal_param_node]: Hello earth!</div>
<div class="line">[minimal_param_node-1] [INFO] [1693708271.685769066] [custom_minimal_param_node]: Hello world!</div>
</div><!-- fragment --><p>&gt;You created a node with a custom parameter that can be set either from a launch file or the command line. You added the dependencies, executables, and a launch file to the package configuration files so that you could build and run them, and see the parameter in action.</p>
<h2><a class="anchor" id="autotoc_md155"></a>
Using &lt;tt&gt;ros2doctor&lt;/tt&gt; to identify issues</h2>
<blockquote class="doxtable">
<p>When your ROS 2 setup is not running as expected, you can check its settings with the <code>ros2doctor</code> tool. <code>ros2doctor</code> checks all aspects of ROS 2, including platform, version, network, environment, running systems and more, and warns you about possible errors and reasons for issues. </p>
</blockquote>
<div class="fragment"><div class="line">ros2 doctor</div>
</div><!-- fragment --><p>Run turtle sim and teleop key, and run ros2doctor, it'll show that: </p><div class="fragment"><div class="line">UserWarning: Publisher without subscriber detected on /turtle1/color_sensor.</div>
<div class="line">UserWarning: Publisher without subscriber detected on /turtle1/pose.</div>
</div><!-- fragment --> <blockquote class="doxtable">
<p>It seems that the /turtlesim node publishes data to two topics that aren’t being subscribed to, and ros2doctor thinks this could possibly lead to issues. If you run commands to echo the /color_sensor and /pose topics, those warnings will disappear because the publishers will have subscribers. </p>
</blockquote>
<p>To get a full report: </p><div class="fragment"><div class="line">ros2 doctor --report</div>
</div><!-- fragment --><p><b>Crosscheck the information</b> from <code>ros2 doctor</code> and <code>ros2 doctor --report</code> to identify the issue. &gt;For example, if ros2doctor returned the warning (mentioned earlier) that your distribution is “not fully supported or tested”, you might take a look at the ROS 2 INFORMATION section of the report: </p><div class="fragment"><div class="line">distribution name      : &lt;distro&gt;</div>
<div class="line">distribution type      : ros2</div>
<div class="line">distribution status    : prerelease # it&#39;s not fully supported</div>
<div class="line">release platforms      : {&#39;&lt;platform&gt;&#39;: [&#39;&lt;version&gt;&#39;]}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md156"></a>
Creating and using Plugins (C++)</h2>
<p>&gt;<code>pluginlib</code> is a C++ library for <b>loading and unloading plugins from within a ROS package.</b> Plugins are dynamically loadable classes that are loaded from a runtime library (i.e. shared object, dynamically linked library). With pluginlib, one does not have to explicitly link their application against the library containing the classes – instead pluginlib can open a library containing exported classes at any point without the application having any prior awareness of the library or the header file containing the class definition. Plugins are useful for extending/modifying application behavior without needing the application source code.</p>
<p>Install the plugin library first: </p><div class="fragment"><div class="line">sudo apt-get install ros-humble-pluginlib</div>
</div><!-- fragment --><p>&gt;In this tutorial, you will create two new packages, one that defines the base class, and another that provides the plugins. The base class will define a generic polygon class, and then our plugins will define specific shapes.</p>
<p>First, create the package (it creates a node named area_node(where a source file <code>area_node.cpp</code> is created), we can tell it from the <code>CMakeLists.txt</code> file): </p><div class="fragment"><div class="line">ros2 pkg create --build-type ament_cmake polygon_base --dependencies pluginlib --node-name area_node</div>
</div><!-- fragment --><p> Inside the include directory of the package, the /polygon_base/regular_polygon.hpp defines: </p><div class="fragment"><div class="line">#ifndef POLYGON_BASE_REGULAR_POLYGON_HPP</div>
<div class="line">#define POLYGON_BASE_REGULAR_POLYGON_HPP</div>
<div class="line"> </div>
<div class="line">namespace polygon_base</div>
<div class="line">{</div>
<div class="line">  class RegularPolygon</div>
<div class="line">  {</div>
<div class="line">    public:</div>
<div class="line">      virtual void initialize(double side_length) = 0;</div>
<div class="line">      virtual double area() = 0;</div>
<div class="line">      virtual ~RegularPolygon(){}</div>
<div class="line"> </div>
<div class="line">    protected:</div>
<div class="line">      RegularPolygon(){} // this is needed with pluginlib</div>
<div class="line">  };</div>
<div class="line">}  // namespace polygon_base</div>
<div class="line"> </div>
<div class="line">#endif  // POLYGON_BASE_REGULAR_POLYGON_HPP</div>
</div><!-- fragment --><p> <a href="https://shengyu7697.github.io/cpp-virtual/">This is the link about the syntax, virtual</a> &gt;<b>With pluginlib, a constructor without parameters is required, so if any parameters to the class are needed, we use the initialize method to pass them to the object.</b></p>
<p>To make this header available to other classes, add to the <code>CMakeLists.txt</code> file: </p><div class="fragment"><div class="line">install(</div>
<div class="line">  DIRECTORY include/</div>
<div class="line">  DESTINATION include</div>
<div class="line">)</div>
</div><!-- fragment --><p> and add this before the <code>ament_package</code> command: </p><div class="fragment"><div class="line">ament_export_include_directories(</div>
<div class="line">  include</div>
<div class="line">)</div>
</div><!-- fragment --><p>Then, create the second package, which is the plugin package. (it creates a package named <code>polygon_plugins</code>, with dependencies <code>polygon_base</code>(the one we just created) and <code>pluginlib</code>) (it also creates a directory as the library named <code>polygon_plugins</code>, under the <code>include</code> directory)(it also creates a source file <code>polygon_plugins.cpp</code> under <code>src</code>) </p><div class="fragment"><div class="line">ros2 pkg create --build-type ament_cmake polygon_plugins --dependencies polygon_base pluginlib --library-name polygon_plugins</div>
</div><!-- fragment --><p>In previous examples, we've use the code from another package, but in the form of static linking libraries. For now, with plugins, we can treate the other package as a dynamic linked library. We can tell that from the include syntax. One uses <code>""</code>, and now we use <code>&lt;&gt;</code>.</p>
<p>Inside the source file <code>polygon_plugins.cpp</code>, it implements the abstract classes defined in package <code>polygon_base</code>. But here's the special thing. The last three lines of the code: </p><div class="fragment"><div class="line">#include &lt;pluginlib/class_list_macros.hpp&gt;</div>
<div class="line"> </div>
<div class="line">PLUGINLIB_EXPORT_CLASS(polygon_plugins::Square, polygon_base::RegularPolygon)</div>
<div class="line">PLUGINLIB_EXPORT_CLASS(polygon_plugins::Triangle, polygon_base::RegularPolygon)</div>
</div><!-- fragment --><p> (quoted from the tutorial) The only piece that is pluginlib-specific is the last three lines, which invokes some magical macros that <b>register the classes as actual plugins</b>. Let’s go through the arguments to the PLUGINLIB_EXPORT_CLASS macro:</p><ol type="1">
<li>The fully-qualified <b>type of the plugin class</b>, in this case, polygon_plugins::Square.</li>
<li>The fully-qualified <b>type of the base class</b>, in this case, polygon_base::RegularPolygon</li>
</ol>
<p>We've already make it so that the plugins can be created once the library is loaded, but the plugin loader still needs a way to find that library and to know what to reference within the library. Thus, we add another xml file, along with the two export lines above, makes everything available to the ROS toolchain. </p><div class="fragment"><div class="line">&lt;library path=&quot;polygon_plugins&quot;&gt;</div>
<div class="line">  &lt;class type=&quot;polygon_plugins::Square&quot; base_class_type=&quot;polygon_base::RegularPolygon&quot;&gt;</div>
<div class="line">    &lt;description&gt;This is a square plugin.&lt;/description&gt;</div>
<div class="line">  &lt;/class&gt;</div>
<div class="line">  &lt;class type=&quot;polygon_plugins::Triangle&quot; base_class_type=&quot;polygon_base::RegularPolygon&quot;&gt;</div>
<div class="line">    &lt;description&gt;This is a triangle plugin.&lt;/description&gt;</div>
<div class="line">  &lt;/class&gt;</div>
<div class="line">&lt;/library&gt;</div>
<div class="line"># this specifies the library the plugin loader wants to find.</div>
<div class="line"># the references within this library are specified as base_class_type</div>
</div><!-- fragment --><p> (quoted from the tutorial)</p><ol type="1">
<li>The library tag gives the relative path to a library that contains the plugins that we want to export. In ROS 2, that is just the name of the library, which is <code>polygon_plugins</code></li>
<li><b>The class tag declares a plugin that we want to export from our library.</b> Let’s go through its parameters:<ul>
<li><code>type</code>: The fully qualified type of the plugin. For us, that’s polygon_plugins::Square.</li>
<li><code>base_class</code>: The fully qualified base class type for the plugin. For us, that’s polygon_base::RegularPolygon.</li>
<li><code>description</code>: A description of the plugin and what it does.</li>
</ul>
</li>
</ol>
<p>After specifying the xml file, the last step is to export the plugins via <code>CMakeLists.txt</code>. This is a change from ROS 1, where the exporting was done via package.xml. Add the following line to your ros2_ws/src/polygon_plugins/CMakeLists.txt after the line reading find_package(pluginlib REQUIRED): </p><div class="fragment"><div class="line">pluginlib_export_plugin_description_file(polygon_base plugins.xml)</div>
</div><!-- fragment --><ol type="1">
<li>(the package with the base class <code>polygon_base</code>)</li>
<li>(export the plugin as the <code>plugins.xml</code> specified)</li>
</ol>
<p>Now, we can use this package as plugins in any other packages. For this tutorial, we use the plugins in the base package <code>polygon_base</code>. </p><div class="fragment"><div class="line">#include &lt;pluginlib/class_loader.hpp&gt;</div>
<div class="line">#include &lt;polygon_base/regular_polygon.hpp&gt;</div>
<div class="line"> </div>
<div class="line">int main(int argc, char** argv)</div>
<div class="line">{</div>
<div class="line">  // To avoid unused parameter warnings</div>
<div class="line">  (void) argc;</div>
<div class="line">  (void) argv;</div>
<div class="line"> </div>
<div class="line">  pluginlib::ClassLoader&lt;polygon_base::RegularPolygon&gt; poly_loader(&quot;polygon_base&quot;, &quot;polygon_base::RegularPolygon&quot;);</div>
<div class="line"> </div>
<div class="line">  try</div>
<div class="line">  {</div>
<div class="line">    std::shared_ptr&lt;polygon_base::RegularPolygon&gt; triangle = poly_loader.createSharedInstance(&quot;polygon_plugins::Triangle&quot;);</div>
<div class="line">    triangle-&gt;initialize(10.0);</div>
<div class="line"> </div>
<div class="line">    std::shared_ptr&lt;polygon_base::RegularPolygon&gt; square = poly_loader.createSharedInstance(&quot;polygon_plugins::Square&quot;);</div>
<div class="line">    square-&gt;initialize(10.0);</div>
<div class="line"> </div>
<div class="line">    printf(&quot;Triangle area: %.2f\n&quot;, triangle-&gt;area());</div>
<div class="line">    printf(&quot;Square area: %.2f\n&quot;, square-&gt;area());</div>
<div class="line">  }</div>
<div class="line">  catch(pluginlib::PluginlibException&amp; ex)</div>
<div class="line">  {</div>
<div class="line">    printf(&quot;The plugin failed to load for some reason. Error: %s\n&quot;, ex.what());</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p> &gt;There are a number of ways to instantiate an instance of the class. In this example, we’re using shared pointers. We just need to call <code>createSharedInstance</code> with the fully-qualified type of the plugin class, in this case, <code>polygon_plugins::Square</code>.</p>
<p>&gt;Important note: the <code>polygon_base</code> package in which this node is defined does NOT depend on the <code>polygon_plugins</code> class. <b>The plugins will be loaded dynamically without any dependency needing to be declared</b>. Furthermore, we’re instantiating the classes with hardcoded plugin names, but you can also do so dynamically with parameters, etc.</p>
<p>Then, build it, source it, then run it: </p><div class="fragment"><div class="line">colcon build --packages-select polygon_base polygon_plugins</div>
<div class="line">source install/setup.bash</div>
<div class="line">ros2 run polygon_base area_node</div>
</div><!-- fragment --> <div class="fragment"><div class="line">Triangle area: 43.30</div>
<div class="line">Square area: 100.00</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md157"></a>
Intermediate</h1>
<h2><a class="anchor" id="autotoc_md158"></a>
Managing Dependecies with &lt;tt&gt;rosdep&lt;/tt&gt;</h2>
<p>&gt;rosdep is a dependency management utility that can work with packages and external libraries. It is a command-line utility for identifying and installing dependencies to build or install a package. rosdep is not a package manager in its own right; it is a meta-package manager that uses its own knowledge of the system and the dependencies to find the appropriate package to install on a particular platform. The actual installation is done using the system package manager (e.g. apt on Debian/Ubuntu, dnf on Fedora/RHEL, etc). It is most often invoked before building a workspace, where it is used to install the dependencies of the packages within that workspace. It has the ability to work over a single package or over a directory of packages (e.g. workspace).</p>
<p>The package.xml is the file in your software where rosdep finds the set of dependencies. It is important that the list of dependencies in the package.xml is complete and correct, which allows all of the tooling to determine the packages dependencies. The dependencies in the package.xml file are generally referred to as “rosdep keys”.</p><ul>
<li>**<code>&lt;depend&gt;</code>**: These are dependencies that should be provided at both build time and run time for your package. For C++ packages, if in doubt, use this tag. Pure Python packages generally don’t have a build phase, so should never use this and should use &lt;exec_depend&gt; instead.</li>
<li>**<code>&lt;build_depend&gt;</code>**: If you only use a particular dependency for building your package, and not at execution time, you can use the &lt;build_depend&gt; tag. With this type of dependency, an installed binary of your package does not require that particular package to be installed.</li>
<li>**<code>&lt;build_export_depend&gt;</code>**: This tag is used when your package exports headers or other resources that depend on a specific package. It ensures that packages depending on your package for building have access to these resources.</li>
<li>**<code>&lt;exec_depend&gt;</code>**: This tag declares dependencies for shared libraries, executables, Python modules, launch scripts and other files required when running your package.</li>
<li>**<code>&lt;test_depend&gt;</code>**:his tag declares dependencies needed only by tests. Dependencies here should not be duplicated with keys specified by &lt;build_depend&gt;, &lt;exec_depend&gt;, or &lt;depend&gt;</li>
</ul>
<p>&gt;rosdep will check for package.xml files in its path or for a specific package and find the rosdep keys stored within. These keys are then cross-referenced against a central index to find the appropriate ROS package or software library in various package managers. Finally, once the packages are found, they are installed and ready to go! rosdep works by retrieving the central index on to your local machine so that it doesn’t have to access the network every time it runs (on Debian/Ubuntu the configuration for it is stored in /etc/ros/rosdep/sources.list.d/20-default.list). The central index is known as rosdistro, which may be found online. We’ll explore that more in the next section.</p>
<p>Install all the dependencies over a workspace with root src. </p><div class="fragment"><div class="line">rosdep install --from-paths src -y --ignore-src</div>
</div><!-- fragment --><ul>
<li>&ndash;from-paths src specifies the path to check for package.xml files to resolve keys for</li>
<li>-y means to default yes to all prompts from the package manager to install without prompts</li>
<li>&ndash;ignore-src means to ignore installing dependencies, even if a rosdep key exists, if the package itself is also in the workspace.</li>
</ul>
<p>There are additional arguments and options available. Use rosdep -h to see them.</p>
<h2><a class="anchor" id="autotoc_md159"></a>
Creating an action</h2>
<p>Actions are defined in .action files of the form: </p><div class="fragment"><div class="line"># Request</div>
<div class="line">---</div>
<div class="line"># Result</div>
<div class="line">---</div>
<div class="line"># Feedback</div>
</div><!-- fragment --><ul>
<li>request: initiating a new goal</li>
<li>result: goal is done</li>
<li>feedback: periodical updates about the goal</li>
<li>goal: the instance of an action</li>
</ul>
<p>Create <code>/action/Fibonacci.action</code> inside the package: </p><div class="fragment"><div class="line">int32 order</div>
<div class="line">---</div>
<div class="line">int32[] sequence</div>
<div class="line">---</div>
<div class="line">int32[] partial_sequence</div>
</div><!-- fragment --><p> Before we can use the action interface, remember we should transfer it into C-code. Thus, we should use the interface generator included in <code>CMakeLists.txt</code>. </p><div class="fragment"><div class="line">find_package(rosidl_default_generators REQUIRED)</div>
<div class="line"> </div>
<div class="line">rosidl_generate_interfaces(${PROJECT_NAME}</div>
<div class="line">  &quot;action/Fibonacci.action&quot;</div>
<div class="line">)</div>
</div><!-- fragment --><p> Also, we should change the <code>package.xml</code> for that build tool and cpp header source. </p><div class="fragment"><div class="line">&lt;buildtool_depend&gt;rosidl_default_generators&lt;/buildtool_depend&gt;</div>
<div class="line">&lt;depend&gt;action_msgs&lt;/depend&gt;</div>
<div class="line">&lt;member_of_group&gt;rosidl_interface_packages&lt;/member_of_group&gt;</div>
</div><!-- fragment --><p>Then, build it, source it, then run it </p><div class="fragment"><div class="line">colcon build</div>
<div class="line">source install/setup.bash</div>
<div class="line">ros2 interface show action_tutorials_interfaces/action/Fibonacci</div>
</div><!-- fragment --><p> And here's the result: </p><div class="fragment"><div class="line">docker@ros2:~/ws/src/ros2_ws$ ros2 interface show action_tutorials_interfaces/action/Fibonacci</div>
<div class="line">int32 order</div>
<div class="line">---</div>
<div class="line">int32[] sequence</div>
<div class="line">---</div>
<div class="line">int32[] partial_sequence</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md160"></a>
Writing an action server and client (C++)</h2>
<p>First, create a package </p><div class="fragment"><div class="line"># in /ro2_ws/src</div>
<div class="line">ros2 pkg create --dependencies action_tutorials_interfaces rclcpp rclcpp_action rclcpp_components -- action_tutorials_cpp</div>
</div><!-- fragment --> <blockquote class="doxtable">
<p>In order to make the package compile and work on Windows, we need to add in some “visibility control”. </p>
</blockquote>
<p>Create <code>action_tutorials_cpp/include/action_tutorials_cpp/visibility_control.h</code> and put: </p><div class="fragment"><div class="line">#ifndef ACTION_TUTORIALS_CPP__VISIBILITY_CONTROL_H_</div>
<div class="line">#define ACTION_TUTORIALS_CPP__VISIBILITY_CONTROL_H_</div>
<div class="line"> </div>
<div class="line">#ifdef __cplusplus</div>
<div class="line">extern &quot;C&quot;</div>
<div class="line">{</div>
<div class="line">#endif</div>
<div class="line"> </div>
<div class="line">// This logic was borrowed (then namespaced) from the examples on the gcc wiki:</div>
<div class="line">//     https://gcc.gnu.org/wiki/Visibility</div>
<div class="line"> </div>
<div class="line">#if defined _WIN32 || defined __CYGWIN__</div>
<div class="line">  #ifdef __GNUC__</div>
<div class="line">    #define ACTION_TUTORIALS_CPP_EXPORT __attribute__ ((dllexport))</div>
<div class="line">    #define ACTION_TUTORIALS_CPP_IMPORT __attribute__ ((dllimport))</div>
<div class="line">  #else</div>
<div class="line">    #define ACTION_TUTORIALS_CPP_EXPORT __declspec(dllexport)</div>
<div class="line">    #define ACTION_TUTORIALS_CPP_IMPORT __declspec(dllimport)</div>
<div class="line">  #endif</div>
<div class="line">  #ifdef ACTION_TUTORIALS_CPP_BUILDING_DLL</div>
<div class="line">    #define ACTION_TUTORIALS_CPP_PUBLIC ACTION_TUTORIALS_CPP_EXPORT</div>
<div class="line">  #else</div>
<div class="line">    #define ACTION_TUTORIALS_CPP_PUBLIC ACTION_TUTORIALS_CPP_IMPORT</div>
<div class="line">  #endif</div>
<div class="line">  #define ACTION_TUTORIALS_CPP_PUBLIC_TYPE ACTION_TUTORIALS_CPP_PUBLIC</div>
<div class="line">  #define ACTION_TUTORIALS_CPP_LOCAL</div>
<div class="line">#else</div>
<div class="line">  #define ACTION_TUTORIALS_CPP_EXPORT __attribute__ ((visibility(&quot;default&quot;)))</div>
<div class="line">  #define ACTION_TUTORIALS_CPP_IMPORT</div>
<div class="line">  #if __GNUC__ &gt;= 4</div>
<div class="line">    #define ACTION_TUTORIALS_CPP_PUBLIC __attribute__ ((visibility(&quot;default&quot;)))</div>
<div class="line">    #define ACTION_TUTORIALS_CPP_LOCAL  __attribute__ ((visibility(&quot;hidden&quot;)))</div>
<div class="line">  #else</div>
<div class="line">    #define ACTION_TUTORIALS_CPP_PUBLIC</div>
<div class="line">    #define ACTION_TUTORIALS_CPP_LOCAL</div>
<div class="line">  #endif</div>
<div class="line">  #define ACTION_TUTORIALS_CPP_PUBLIC_TYPE</div>
<div class="line">#endif</div>
<div class="line"> </div>
<div class="line">#ifdef __cplusplus</div>
<div class="line">}</div>
<div class="line">#endif</div>
<div class="line"> </div>
<div class="line">#endif  // ACTION_TUTORIALS_CPP__VISIBILITY_CONTROL_H_</div>
</div><!-- fragment --><p> Honestly, I don't understand what is going on here. But we can start writing an action server computing Fibonacci. Create <code>/src/fibonacci_action_server.cpp</code>. We should also add a few lines to <code>CMakeLists.txt</code> to maintain dependencies. <a href="https://shengyu7697.github.io/cpp-explicit/">About cpp syntax explicit</a></p>
<div class="fragment"><div class="line"># ... find packages</div>
<div class="line"> </div>
<div class="line">add_library(action_server SHARED</div>
<div class="line">  src/fibonacci_action_server.cpp)</div>
<div class="line">target_include_directories(action_server PRIVATE</div>
<div class="line">  $&lt;BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include&gt;</div>
<div class="line">  $&lt;INSTALL_INTERFACE:include&gt;)</div>
<div class="line">target_compile_definitions(action_server</div>
<div class="line">  PRIVATE &quot;ACTION_TUTORIALS_CPP_BUILDING_DLL&quot;)</div>
<div class="line">ament_target_dependencies(action_server</div>
<div class="line">  &quot;action_tutorials_interfaces&quot;</div>
<div class="line">  &quot;rclcpp&quot;</div>
<div class="line">  &quot;rclcpp_action&quot;</div>
<div class="line">  &quot;rclcpp_components&quot;)</div>
<div class="line">rclcpp_components_register_node(action_server PLUGIN &quot;action_tutorials_cpp::FibonacciActionServer&quot; EXECUTABLE fibonacci_action_server)</div>
<div class="line">install(TARGETS</div>
<div class="line">  action_server</div>
<div class="line">  ARCHIVE DESTINATION lib</div>
<div class="line">  LIBRARY DESTINATION lib</div>
<div class="line">  RUNTIME DESTINATION bin)</div>
</div><!-- fragment --><p> Then run <code>colcon build</code>. It should build <code>fibonacci_action_server.cpp</code> in <code>action_tutorials_cpp</code> pacakge.</p>
<p>We also instantiate a ROS timer that will kick off the one and only call to send_goal: </p><div class="fragment"><div class="line">this-&gt;timer_ = this-&gt;create_wall_timer(</div>
<div class="line">  std::chrono::milliseconds(500),</div>
<div class="line">  std::bind(&amp;FibonacciActionClient::send_goal, this));</div>
</div><!-- fragment --><p> <a href="https://www.jyt0532.com/2017/01/08/bind/">About std::bind</a></p>
<p>And similarly, build the client as well. <code>CMakeLists.txt</code>: </p><div class="fragment"><div class="line">add_library(action_client SHARED</div>
<div class="line">  src/fibonacci_action_client.cpp)</div>
<div class="line">target_include_directories(action_client PRIVATE</div>
<div class="line">  $&lt;BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include&gt;</div>
<div class="line">  $&lt;INSTALL_INTERFACE:include&gt;)</div>
<div class="line">target_compile_definitions(action_client</div>
<div class="line">  PRIVATE &quot;ACTION_TUTORIALS_CPP_BUILDING_DLL&quot;)</div>
<div class="line">ament_target_dependencies(action_client</div>
<div class="line">  &quot;action_tutorials_interfaces&quot;</div>
<div class="line">  &quot;rclcpp&quot;</div>
<div class="line">  &quot;rclcpp_action&quot;</div>
<div class="line">  &quot;rclcpp_components&quot;)</div>
<div class="line">rclcpp_components_register_node(action_client PLUGIN &quot;action_tutorials_cpp::FibonacciActionClient&quot; EXECUTABLE fibonacci_action_client)</div>
<div class="line">install(TARGETS</div>
<div class="line">  action_client</div>
<div class="line">  ARCHIVE DESTINATION lib</div>
<div class="line">  LIBRARY DESTINATION lib</div>
<div class="line">  RUNTIME DESTINATION bin)</div>
</div><!-- fragment --> <div class="fragment"><div class="line">After that, source it then run it. Here&#39;s the result:</div>
<div class="line">- client</div>
</div><!-- fragment --><p> docker@ros2:~/ws/src/ros2_ws$ ros2 run action_tutorials_cpp fibonacci_action_client [INFO] [1693889845.150850325] [fibonacci_action_client]: Sending goal [INFO] [1693889845.152368070] [fibonacci_action_client]: Goal accepted by server, waiting for result [INFO] [1693889845.153103892] [fibonacci_action_client]: Next number in sequence received: 0 1 1 [INFO] [1693889846.152979478] [fibonacci_action_client]: Next number in sequence received: 0 1 1 2 [INFO] [1693889847.152965399] [fibonacci_action_client]: Next number in sequence received: 0 1 1 2 3 [INFO] [1693889848.152860585] [fibonacci_action_client]: Next number in sequence received: 0 1 1 2 3 5 [INFO] [1693889849.153781401] [fibonacci_action_client]: Next number in sequence received: 0 1 1 2 3 5 8 [INFO] [1693889850.153472725] [fibonacci_action_client]: Next number in sequence received: 0 1 1 2 3 5 8 13 [INFO] [1693889851.152991279] [fibonacci_action_client]: Next number in sequence received: 0 1 1 2 3 5 8 13 21 [INFO] [1693889852.153055651] [fibonacci_action_client]: Next number in sequence received: 0 1 1 2 3 5 8 13 21 34 [INFO] [1693889853.153347930] [fibonacci_action_client]: Next number in sequence received: 0 1 1 2 3 5 8 13 21 34 55 [INFO] [1693889854.153263697] [fibonacci_action_client]: Result received: 0 1 1 2 3 5 8 13 21 34 55 </p><div class="fragment"><div class="line">- server(it keeps running after the first goal is succeeded and waits for another request)</div>
</div><!-- fragment --><p> docker@ros2:~/ws/src/ros2_ws$ ros2 run action_tutorials_cpp fibonacci_action_server [INFO] [1693889845.151792653] [fibonacci_action_server]: Received goal request with order 10 [INFO] [1693889845.152439773] [fibonacci_action_server]: Executing goal [INFO] [1693889845.152817284] [fibonacci_action_server]: Publish feedback [INFO] [1693889846.152782472] [fibonacci_action_server]: Publish feedback [INFO] [1693889847.152374881] [fibonacci_action_server]: Publish feedback [INFO] [1693889848.152729281] [fibonacci_action_server]: Publish feedback [INFO] [1693889849.153213684] [fibonacci_action_server]: Publish feedback [INFO] [1693889850.153044611] [fibonacci_action_server]: Publish feedback [INFO] [1693889851.152767172] [fibonacci_action_server]: Publish feedback [INFO] [1693889852.152774342] [fibonacci_action_server]: Publish feedback [INFO] [1693889853.153034720] [fibonacci_action_server]: Publish feedback [INFO] [1693889854.152972188] [fibonacci_action_server]: Goal succeeded</p>
<div class="fragment"><div class="line">### Composing multiple nodes in a single process</div>
<div class="line">[About components](https://docs.ros.org/en/humble/Concepts/Intermediate/About-Composition.html)</div>
<div class="line">This tutorial uses rclcpp_components, ros2component, and composition packages. Before we start, we should download the composition package into our workspace. That package ```composition``` is a demo package that runs in overlay. The other two packages, which are ```rclcpp_components``` and ```ros2component```, are packages that runs in underlay and already downloaded in the ros distro ```/opt/ros/humble```. (It took me a while to realize that :D)</div>
<div class="line"> </div>
<div class="line">- [About ament_cmake](https://docs.ros.org/en/humble/How-To-Guides/Ament-CMake-Documentation.html)</div>
<div class="line">    &gt; ament_cmake is the build system for CMake based packages in ROS 2 (in particular, it will be used for most C/C++ projects). </div>
<div class="line"> </div>
<div class="line">So, we first download the package ```composition``` into our workspace, then build it, and source it.</div>
</div><!-- fragment --><p> colcon build # just build the whole workspace source install/setup.bash </p><div class="fragment"><div class="line">To see what components are registered and available in the workspace:</div>
</div><!-- fragment --><p> docker@ros2:~/ws/src/ros2_ws$ ros2 component types composition composition::Talker composition::Listener composition::NodeLikeListener composition::Server composition::Client action_tutorials_cpp action_tutorials_cpp::FibonacciActionServer action_tutorials_cpp::FibonacciActionClient robot_state_publisher robot_state_publisher::RobotStatePublisher tf2_ros tf2_ros::StaticTransformBroadcasterNode </p><div class="fragment"><div class="line">These are the available components, which is the ROS2 APIs.</div>
<div class="line"> </div>
<div class="line">#### Run-time composition using ROS services with a publisher and subscriber</div>
<div class="line">Run the node ```component_containter``` in package ```rclcpp_components``` first so that we can load components to run.</div>
</div><!-- fragment --><p> ros2 run rclcpp_components component_container </p><div class="fragment"><div class="line">Then, in the second shell, verify that the component container is running properly:</div>
</div><!-- fragment --><p> docker@ros2:~/ws/src/ros2_ws$ ros2 component list /ComponentManager </p><div class="fragment"><div class="line">Once the container is running properly, we can now load the component ```composition::Talker``` inside the package ```composition``` into the container ```/ComponentManager```.</div>
</div><!-- fragment --><p> docker@ros2:~/ws/src/ros2_ws$ ros2 component load /ComponentManager composition composition::Talker Loaded component 1 into '/ComponentManager' container node as '/talker' </p><div class="fragment"><div class="line">Then, load the listener into the container as well.</div>
</div><!-- fragment --><p> docker@ros2:~/ws/src/ros2_ws$ ros2 component load /ComponentManager composition composition::Listener Loaded component 2 into '/ComponentManager' container node as '/listener' </p><div class="fragment"><div class="line">Now, we check the state of the components here:</div>
</div><!-- fragment --><p> docker@ros2:~/ws/src/ros2_ws$ ros2 component list /ComponentManager 1 /talker 2 /listener </p><div class="fragment"><div class="line">Once the listner and the talker are running, in the first terminal where the container is executed, messages are shown:</div>
</div><!-- fragment --><p> ... [INFO] [1693994957.099389176] [talker]: Publishing: 'Hello World: 108' [INFO] [1693994957.099621378] [listener]: I heard: [Hello World: 108] ... </p><div class="fragment"><div class="line">We can unload the components using the unique id:</div>
</div><!-- fragment --><p> ros2 component unload /ComponentManager 1 2 </p><div class="fragment"></div><!-- fragment --><p> Unloaded component 1 from '/ComponentManager' container Unloaded component 2 from '/ComponentManager' container </p><div class="fragment"><div class="line">#### Run-time composition using ROS services with a server and client</div>
<div class="line">Similar to the first example, we first execute the container in the first terminal, then run the server and client in the second terminal.</div>
</div><!-- fragment --><p> ros2 run rclcpp_components component_container </p><div class="fragment"></div><!-- fragment --><p> ros2 component load /ComponentManager composition composition::Server ros2 component load /ComponentManager composition composition::Client </p><div class="fragment"><div class="line">#### Compile-time composition using ROS services</div>
<div class="line">&gt;This demos shows that **the same shared libraries can be reused to compile a single executable running multiple components**. The executable contains all four components from above: talker and listener as well as server and client.</div>
<div class="line"> </div>
<div class="line">To run all the components with the package&#39;s own source file:</div>
</div><!-- fragment --><p> ros2 run composition manual_composition </p><div class="fragment"><div class="line">#### Run-time composition using dlopen</div>
<div class="line">&gt; This demo presents an alternative to run-time composition by creating a generic container process and explicitly passing the libraries to load without using ROS interfaces. The process will open each library and create one instance of each “rclcpp::Node” class in the library source code.</div>
</div><!-- fragment --><p> docker@ros2:~/ws/src/ros2_ws$ ros2 run composition dlopen_composition <code>ros2 pkg prefix composition</code>/lib/libtalker_component.so <code>ros2 pkg prefix composition</code>/lib/liblistener_component.so [INFO] [1693996242.201452547] [dlopen_composition]: Load library /home/docker/ws/src/ros2_ws/src/install/composition/lib/libtalker_component.so [INFO] [1693996242.274358002] [dlopen_composition]: Instantiate class rclcpp_components::NodeFactoryTemplate&lt;composition::Talker&gt; [INFO] [1693996242.660578628] [dlopen_composition]: Load library /home/docker/ws/src/ros2_ws/src/install/composition/lib/liblistener_component.so [INFO] [1693996242.774907073] [dlopen_composition]: Instantiate class rclcpp_components::NodeFactoryTemplate&lt;composition::Listener&gt; [INFO] [1693996243.660757866] [talker]: Publishing: 'Hello World: 1' [INFO] [1693996243.671404989] [listener]: I heard: [Hello World: 1] </p><div class="fragment"><div class="line">[About .so file](https://superuser.com/questions/71404/what-is-an-so-file)</div>
<div class="line"> </div>
<div class="line">#### Composition using launch actions</div>
<div class="line">While the command line tools are useful for debugging and diagnosing component configurations, it is frequently more convenient to start a set of components at the same time. </div>
</div><!-- fragment --><p> ros2 launch composition composition_demo_launch.py </p><div class="fragment"><div class="line">(Note that there&#39;s a typo on the tutorial: ```composition_demo.launch.py``` -&gt; ```composition_demo_launch.py```)</div>
<div class="line">And here&#39;s the result:</div>
</div><!-- fragment --><p> [INFO] [launch]: All log files can be found below /home/docker/.ros/log/2023-09-06-18-33-58-732464-ros2-9919 [INFO] [launch]: Default logging verbosity is set to INFO [INFO] [component_container-1]: process started with pid [9932] [component_container-1] [INFO] [1693996446.892453985] [my_container]: Load Library: /home/docker/ws/src/ros2_ws/src/install/composition/lib/libtalker_component.so [component_container-1] [INFO] [1693996446.975510948] [my_container]: Found class: rclcpp_components::NodeFactoryTemplate&lt;composition::Talker&gt; [component_container-1] [INFO] [1693996446.975592848] [my_container]: Instantiate class: rclcpp_components::NodeFactoryTemplate&lt;composition::Talker&gt; [INFO] [launch_ros.actions.load_composable_nodes]: Loaded node '/talker' in container '/my_container' [component_container-1] [INFO] [1693996447.333908942] [my_container]: Load Library: /home/docker/ws/src/ros2_ws/src/install/composition/lib/liblistener_component.so [component_container-1] [INFO] [1693996447.463670364] [my_container]: Found class: rclcpp_components::NodeFactoryTemplate&lt;composition::Listener&gt; [component_container-1] [INFO] [1693996447.463759565] [my_container]: Instantiate class: rclcpp_components::NodeFactoryTemplate&lt;composition::Listener&gt; [INFO] [launch_ros.actions.load_composable_nodes]: Loaded node '/listener' in container '/my_container' [component_container-1] [INFO] [1693996448.098694799] [talker]: Publishing: 'Hello World: 1' [component_container-1] [INFO] [1693996448.115580893] [listener]: I heard: [Hello World: 1] [component_container-1] [INFO] [1693996449.098506663] [talker]: Publishing: 'Hello World: 2' [component_container-1] [INFO] [1693996449.099018766] [listener]: I heard: [Hello World: 2] </p><div class="fragment"><div class="line">#### Some other usage</div>
<div class="line">We can remap the container name and namespace. For this example, the original node name was ComponentManager. Now, we name it as ```Mycontainer```, with namespace named ```ns```:</div>
</div><!-- fragment --><p> ros2 run rclcpp_components component_container &ndash;ros-args -r __node:=MyContainer -r __ns:=/ns </p><div class="fragment"><div class="line">So, we load components in such way:</div>
</div><!-- fragment --><p> ros2 component load /ns/MyContainer composition composition::Listener </p><div class="fragment"><div class="line">Components names and namespaces can also be remapped:</div>
</div><!-- fragment --><p> ros2 component load /ComponentManager composition composition::Talker &ndash;node-name talker2 ros2 component load /ComponentManager composition composition::Talker &ndash;node-namespace /ns ros2 component load /ComponentManager composition composition::Talker &ndash;node-name talker3 &ndash;node-namespace /ns2 </p><div class="fragment"><div class="line">Here&#39;s the result of ```ros2 component list</div>
</div><!-- fragment --> <div class="fragment"><div class="line">/ComponentManager</div>
<div class="line">   1  /talker2</div>
<div class="line">   2  /ns/talker</div>
<div class="line">   3  /ns2/talker3</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md161"></a>
Monitoring for parameter changes (C++)</h2>
<p>Learn how to use <code>ParameterEventHandler</code> class to monitor the parameter changes to itself or others. However, this tutorial must be running the Galactic distribution of ROS2, while the one run by docker is the humble distribution. So, I'll skip this part for now.</p>
<h2><a class="anchor" id="autotoc_md162"></a>
Launch</h2>
<p>ROS2 Launch files can run and configure multiple executables simultaneously, running multiple ROS2 nodes. </p>
<h3><a class="anchor" id="autotoc_md163"></a>
Creating a Launch File</h3>
<p>The launch files can be written in python, xml, or yaml files. <a href="https://www.freecodecamp.org/news/what-is-yaml-the-yml-file-format/#:~:text=YAML%20is%20a%20human%2Dreadable,application%20using%20a%20standard%20format.">This is the article about xml, json, and yaml</a> They are all configuration files for applications. I decided to try all three types of launch files. First, under the workspace direcotry <code>ros2_ws</code>, create a directory <code>launch</code> to store all the launch files. Then, create the three launch files: </p><div class="fragment"><div class="line">mkdir launch</div>
<div class="line">cd launch</div>
<div class="line">touch turtlesim_mimic_launch.py\</div>
<div class="line">  turtlesim_mimic_launch.xml\</div>
<div class="line">  turtlesim_mimic_launch.yaml</div>
</div><!-- fragment --><ul>
<li>For python: <div class="fragment"><div class="line">from launch import LaunchDescription</div>
<div class="line">from launch_ros.actions import Node</div>
<div class="line"> </div>
<div class="line">def generate_launch_description():</div>
<div class="line">    return LaunchDescription([</div>
<div class="line">        Node(</div>
<div class="line">            package=&#39;turtlesim&#39;,</div>
<div class="line">            namespace=&#39;turtlesim1&#39;,</div>
<div class="line">            executable=&#39;turtlesim_node&#39;,</div>
<div class="line">            name=&#39;sim&#39;</div>
<div class="line">        ),</div>
<div class="line">        Node(</div>
<div class="line">            package=&#39;turtlesim&#39;,</div>
<div class="line">            namespace=&#39;turtlesim2&#39;,</div>
<div class="line">            executable=&#39;turtlesim_node&#39;,</div>
<div class="line">            name=&#39;sim&#39;</div>
<div class="line">        ),</div>
<div class="line">        Node(</div>
<div class="line">            package=&#39;turtlesim&#39;,</div>
<div class="line">            executable=&#39;mimic&#39;,</div>
<div class="line">            name=&#39;mimic&#39;,</div>
<div class="line">            remappings=[</div>
<div class="line">                (&#39;/input/pose&#39;, &#39;/turtlesim1/turtle1/pose&#39;),</div>
<div class="line">                (&#39;/output/cmd_vel&#39;, &#39;/turtlesim2/turtle1/cmd_vel&#39;),</div>
<div class="line">            ]</div>
<div class="line">        )</div>
<div class="line">    ])</div>
</div><!-- fragment --></li>
<li>For xml <div class="fragment"><div class="line">&lt;launch&gt;</div>
<div class="line">  &lt;node pkg=&quot;turtlesim&quot; exec=&quot;turtlesim_node&quot; name=&quot;sim&quot; namespace=&quot;turtlesim1&quot;/&gt;</div>
<div class="line">  &lt;node pkg=&quot;turtlesim&quot; exec=&quot;turtlesim_node&quot; name=&quot;sim&quot; namespace=&quot;turtlesim2&quot;/&gt;</div>
<div class="line">  &lt;node pkg=&quot;turtlesim&quot; exec=&quot;mimic&quot; name=&quot;mimic&quot;&gt;</div>
<div class="line">    &lt;remap from=&quot;/input/pose&quot; to=&quot;/turtlesim1/turtle1/pose&quot;/&gt;</div>
<div class="line">    &lt;remap from=&quot;/output/cmd_vel&quot; to=&quot;/turtlesim2/turtle1/cmd_vel&quot;/&gt;</div>
<div class="line">  &lt;/node&gt;</div>
<div class="line">&lt;/launch&gt;</div>
</div><!-- fragment --></li>
<li>For yaml <div class="fragment"><div class="line">launch:</div>
<div class="line"> </div>
<div class="line">- node:</div>
<div class="line">    pkg: &quot;turtlesim&quot;</div>
<div class="line">    exec: &quot;turtlesim_node&quot;</div>
<div class="line">    name: &quot;sim&quot;</div>
<div class="line">    namespace: &quot;turtlesim1&quot;</div>
<div class="line"> </div>
<div class="line">- node:</div>
<div class="line">    pkg: &quot;turtlesim&quot;</div>
<div class="line">    exec: &quot;turtlesim_node&quot;</div>
<div class="line">    name: &quot;sim&quot;</div>
<div class="line">    namespace: &quot;turtlesim2&quot;</div>
<div class="line"> </div>
<div class="line">- node:</div>
<div class="line">    pkg: &quot;turtlesim&quot;</div>
<div class="line">    exec: &quot;mimic&quot;</div>
<div class="line">    name: &quot;mimic&quot;</div>
<div class="line">    remap:</div>
<div class="line">    -</div>
<div class="line">        from: &quot;/input/pose&quot;</div>
<div class="line">        to: &quot;/turtlesim1/turtle1/pose&quot;</div>
<div class="line">    -</div>
<div class="line">        from: &quot;/output/cmd_vel&quot;</div>
<div class="line">        to: &quot;/turtlesim2/turtle1/cmd_vel&quot;</div>
</div><!-- fragment --></li>
</ul>
<p>Then, run the launch files: </p><div class="fragment"><div class="line">ros2 launch turtlesim_mimic_launch.&lt;file_type&gt;</div>
<div class="line"> </div>
<div class="line"># file type could be .py .xml .yaml</div>
</div><!-- fragment --><p> Two turtlesim windows would show up. Also, note that it's possible that the launch file is inside a package. So that we should specify the package name while we're launching a file: </p><div class="fragment"><div class="line">ros2 launch &lt;package_name&gt; &lt;launch_file_name&gt;</div>
</div><!-- fragment --><p> <b>Also, for packages that has launch file, it's important to add</b> </p><div class="fragment"><div class="line">&lt;exec_depend&gt;ros2launch&lt;/exec_depend&gt;</div>
</div><!-- fragment --><p> <b>to the <code>package.xml</code> file. This helps make sure that the ros2 launch command is available after building your package. It also ensures that all launch file formats are recognized. (quoted from the tutorial)</b></p>
<p>Here's what happened after launching the files: </p><div class="fragment"><div class="line">docker@ros2:~/ws/src/ros2_ws/launch$ ros2 launch turtlesim_mimic_launch.py</div>
<div class="line">[INFO] [launch]: All log files can be found below /home/docker/.ros/log/2023-09-07-13-09-46-732492-ros2-153</div>
<div class="line">[INFO] [launch]: Default logging verbosity is set to INFO</div>
<div class="line">[INFO] [turtlesim_node-1]: process started with pid [154]</div>
<div class="line">[INFO] [turtlesim_node-2]: process started with pid [156]</div>
<div class="line">[INFO] [mimic-3]: process started with pid [158]</div>
<div class="line">[turtlesim_node-2] QStandardPaths: XDG_RUNTIME_DIR not set, defaulting to &#39;/tmp/runtime-docker&#39;</div>
<div class="line">[turtlesim_node-1] QStandardPaths: XDG_RUNTIME_DIR not set, defaulting to &#39;/tmp/runtime-docker&#39;</div>
<div class="line">[turtlesim_node-1] [INFO] [1694063387.082140704] [turtlesim1.sim]: Starting turtlesim with node name /turtlesim1/sim</div>
<div class="line">[turtlesim_node-2] [INFO] [1694063387.082376907] [turtlesim2.sim]: Starting turtlesim with node name /turtlesim2/sim</div>
<div class="line">[turtlesim_node-2] [INFO] [1694063387.089878707] [turtlesim2.sim]: Spawning turtle [turtle1] at x=[5.544445], y=[5.544445], theta=[0.000000]</div>
<div class="line">[turtlesim_node-1] [INFO] [1694063387.089934608] [turtlesim1.sim]: Spawning turtle [turtle1] at x=[5.544445], y=[5.544445], theta=[0.000000]</div>
</div><!-- fragment --><p> Now, in another terminal, we use <code>ros2 pub</code> to publish informations onto the topic so that the turtle could start moving: </p><div class="fragment"><div class="line">ros2 topic pub -r 1 /turtlesim1/turtle1/cmd_vel geometry_msgs/msg/Twist &quot;{linear: {x: 2.0, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: -1.8}}&quot;</div>
</div><!-- fragment --><p> <img src="/ntu_racing_hw/ros2_setup/pictures/Screenshot%202023-09-07%20131638.png" alt="" class="inline"/></p>
<p>Now, in another terminal, run <code>rqt_graph</code> to see the whole graph of current running nodes. Remember to source the setup file first: </p><div class="fragment"><div class="line">source install/setup.bash</div>
<div class="line">rqt_graph</div>
</div><!-- fragment --><p> <img src="/ntu_racing_hw/ros2_setup/pictures/Screenshot%202023-09-07%20132221.png" alt="" class="inline"/></p>
<h3><a class="anchor" id="autotoc_md164"></a>
Integrating launch files into ROS2 packages</h3>
<p>First, build another workspace <code>launch_ws</code> and create an <code>src</code> directory underneath it. Afterwards, create a pacakge for demonstration: </p><div class="fragment"><div class="line">mkdir -p launch_ws/src</div>
<div class="line">cd launch_ws/src</div>
<div class="line">ros2 pkg create cpp_launch_example --build-type ament_cmake</div>
</div><!-- fragment --><p> Now, add a few lines to <code>CMakeLists.txt</code> to install the launch files: </p><div class="fragment"><div class="line"># at the end of the file</div>
<div class="line"># Install launch files.</div>
<div class="line">install(DIRECTORY</div>
<div class="line">  launch</div>
<div class="line">  DESTINATION share/${PROJECT_NAME}/</div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line"># before ament_package()</div>
<div class="line">ament_package()</div>
</div><!-- fragment --><p> Then, create a <code>launch</code> directory and create three launch files: </p><div class="fragment"><div class="line">mkdir launch</div>
<div class="line">cd launch</div>
<div class="line">touch my_script_launch.py my_script_launch.xml my_script_launch.yaml</div>
</div><!-- fragment --><ul>
<li>For python <blockquote class="doxtable">
<p><b>Inside your launch directory, create a new launch file called my_script_launch.py. _launch.py is recommended, but not required, as the file suffix for Python launch files. However, the launch file name needs to end with launch.py to be recognized and autocompleted by ros2 launch.</b> </p>
</blockquote>
<div class="fragment"><div class="line">import launch</div>
<div class="line">import launch_ros.actions</div>
<div class="line"> </div>
<div class="line">def generate_launch_description(): # this function must be named like this, and the return type is fixed as well</div>
<div class="line">  return launch.LaunchDescription([</div>
<div class="line">    launch_ros.actions.Node(</div>
<div class="line">      package=&#39;demo_nodes_cpp&#39;,</div>
<div class="line">      executable=&#39;talker&#39;,</div>
<div class="line">      name=&#39;talker&#39;),</div>
<div class="line">  ])</div>
</div><!-- fragment --></li>
<li>For xml <blockquote class="doxtable">
<p><b>Inside your launch directory, create a new launch file called my_script_launch.xml. _launch.xml is recommended, but not required, as the file suffix for XML launch files.</b> </p>
</blockquote>
<div class="fragment"><div class="line">&lt;launch&gt;</div>
<div class="line">  &lt;node pkg=&quot;demo_nodes_cpp&quot; exec=&quot;talker&quot; name=&quot;talker&quot;/&gt;</div>
<div class="line">&lt;/launch&gt;</div>
</div><!-- fragment --></li>
<li>For yaml <blockquote class="doxtable">
<p><b>Inside your launch directory, create a new launch file called my_script_launch.yaml. _launch.yaml is recommended, but not required, as the file suffix for YAML launch files.</b> </p>
</blockquote>
<div class="fragment"><div class="line">launch:</div>
<div class="line"> </div>
<div class="line">- node:</div>
<div class="line">  pkg: &quot;demo_nodes_cpp&quot;</div>
<div class="line">  exec: &quot;talker&quot;</div>
<div class="line">  name: &quot;talker&quot;</div>
</div><!-- fragment --> Then, build it(in the root directory of the workspace), source it, then launch it. <div class="fragment"><div class="line">colcon build</div>
<div class="line">source install/setup.bash</div>
<div class="line">ros2 launch cpp_launch_example my_script_launch.&lt;file_type&gt;</div>
<div class="line"># file_type could be .py .xml .yaml</div>
</div><!-- fragment --> By the way, remember to install the package <code>demo_nodes_cpp</code> beforehand. Run the following code: <div class="fragment"><div class="line">sudo apt-get install ros-humble-demo-nodes-cpp</div>
<div class="line">source install/setup.bash</div>
</div><!-- fragment --> This would install the package, note that <code>humble</code> term is the ros2 distro. If we're using other distros, then substitute the token with other distro names. After the installation, you should see the package inside the diectory <code>/opt/ros/humble/share/demo_nodes_cpp</code>.</li>
</ul>
<p>**Remember that, if there's any packages you want to install in the future about ros2, use the command </p><div class="fragment"><div class="line">sudo apt-get install ros-&lt;distro&gt;-&lt;pacakge_name&gt;</div>
</div><!-- fragment --><p> Note that the package name should all be connected with "-" instead of "_". Then, the package with name connected with "\_" would be installed afterwards.</p>
<h3><a class="anchor" id="autotoc_md165"></a>
Using substitutions</h3>
<p>Substitutions:</p><ol type="1">
<li>variables that are only evaluated during execution of the launch file</li>
<li>can be used to acquire specific information like a launch configuration, an environment variable, or to evaluate an arbitrary Python expression.</li>
</ol>
<blockquote class="doxtable">
<p>This tutorial shows usage examples of substitutions in ROS 2 launch files. </p>
</blockquote>
<p>First, create a pacakge under the <code>launch_ws</code> workspace, and make a directory <code>launch</code> in it. </p><div class="fragment"><div class="line">ros2 pkg create launch_tutorial --build-type ament_python</div>
<div class="line">mkdir launch_tutorial/launch</div>
</div><!-- fragment --><p>Then, change the setup.py so that the launch files will be installed. </p><div class="fragment"><div class="line">import os # new</div>
<div class="line">from glob import glob</div>
<div class="line">from setuptools import setup</div>
<div class="line"> </div>
<div class="line">package_name = &#39;launch_tutorial&#39;</div>
<div class="line"> </div>
<div class="line">setup(</div>
<div class="line">    # Other parameters ...</div>
<div class="line">    data_files=[</div>
<div class="line">        # ... Other data files</div>
<div class="line">        # Include all launch files.</div>
<div class="line">        (os.path.join(&#39;share&#39;, package_name, &#39;launch&#39;), glob(os.path.join(&#39;launch&#39;, &#39;*launch.[pxy][yma]*&#39;)))</div>
<div class="line">    ]</div>
<div class="line">)</div>
</div><!-- fragment --><p> This part of the code is hardly understandable by first glance. So I went through a few links:</p><ul>
<li><a href="https://www.geeksforgeeks.org/python-os-path-join-method/">About os.path.join()</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10262521">About glob.glob()</a></li>
<li>Also, the almighty ChatGPT First, the setup function defines the package's metadata and configuration. <code>data_files</code> is a list of 2-tuples where each tuple represents a destination directory and a list of files to include, which means include that list of files into the destination directory.</li>
</ul>
<p>Then, let's focus on the tuple we added. The first element of the tuple is the destination, which the <code>os.path.join()</code> method would return a string <code>share/launch_tutorial/launch</code>, where we want to include the file described by the returned list of file names by the <code>glob</code> function.</p>
<p>The <code>glob</code> function would return a list of file paths after searching <code>/launch/*launch.[pxy][yma]*</code> returned by <code>os.path.join()</code>. What is that absurd string? Well, it's special syntax for <code>glob</code> function. Just like how it behaves in Unix like system, * means everything. And <code>[pxy][yma]</code> would search for all with tokens <code>py</code>, <code>xm</code>, and <code>ya</code>. Is it clear now? It'll search for launch files in the <code>.py</code>, <code>.xml</code>, and <code>.yaml</code> formats.</p>
<p>Next, in the <code>launch</code> directory, create a <b>launch file that will call and pass arguments to another launch file</b>. <code>example_main.launch.py</code> (remember that the python launch files should be suffixed "launch.py") </p><div class="fragment"><div class="line">from launch_ros.substitutions import FindPackageShare</div>
<div class="line"> </div>
<div class="line">from launch import LaunchDescription</div>
<div class="line">from launch.actions import IncludeLaunchDescription</div>
<div class="line">from launch.launch_description_sources import PythonLaunchDescriptionSource</div>
<div class="line">from launch.substitutions import PathJoinSubstitution, TextSubstitution</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">def generate_launch_description():</div>
<div class="line">    colors = {</div>
<div class="line">        &#39;background_r&#39;: &#39;200&#39;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    return LaunchDescription([</div>
<div class="line">        IncludeLaunchDescription(</div>
<div class="line">            PythonLaunchDescriptionSource([</div>
<div class="line">                PathJoinSubstitution([</div>
<div class="line">                    FindPackageShare(&#39;launch_tutorial&#39;),</div>
<div class="line">                    &#39;launch&#39;,</div>
<div class="line">                    &#39;example_substitutions.launch.py&#39;</div>
<div class="line">                ])</div>
<div class="line">            ]),</div>
<div class="line">            launch_arguments={</div>
<div class="line">                &#39;turtlesim_ns&#39;: &#39;turtlesim2&#39;,</div>
<div class="line">                &#39;use_provided_red&#39;: &#39;True&#39;,</div>
<div class="line">                &#39;new_background_r&#39;: TextSubstitution(text=str(colors[&#39;background_r&#39;]))</div>
<div class="line">            }.items()</div>
<div class="line">        )</div>
<div class="line">    ])</div>
</div><!-- fragment --><p>And create <code>example_substitutions.launch.py</code> in the <code>launch</code> directory as well. </p><div class="fragment"><div class="line">from launch_ros.actions import Node</div>
<div class="line"> </div>
<div class="line">from launch import LaunchDescription</div>
<div class="line">from launch.actions import DeclareLaunchArgument, ExecuteProcess, TimerAction</div>
<div class="line">from launch.conditions import IfCondition</div>
<div class="line">from launch.substitutions import LaunchConfiguration, PythonExpression</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">def generate_launch_description():</div>
<div class="line">    turtlesim_ns = LaunchConfiguration(&#39;turtlesim_ns&#39;)</div>
<div class="line">    use_provided_red = LaunchConfiguration(&#39;use_provided_red&#39;)</div>
<div class="line">    new_background_r = LaunchConfiguration(&#39;new_background_r&#39;)</div>
<div class="line"> </div>
<div class="line">    turtlesim_ns_launch_arg = DeclareLaunchArgument(</div>
<div class="line">        &#39;turtlesim_ns&#39;,</div>
<div class="line">        default_value=&#39;turtlesim1&#39;</div>
<div class="line">    )</div>
<div class="line">    use_provided_red_launch_arg = DeclareLaunchArgument(</div>
<div class="line">        &#39;use_provided_red&#39;,</div>
<div class="line">        default_value=&#39;False&#39;</div>
<div class="line">    )</div>
<div class="line">    new_background_r_launch_arg = DeclareLaunchArgument(</div>
<div class="line">        &#39;new_background_r&#39;,</div>
<div class="line">        default_value=&#39;200&#39;</div>
<div class="line">    )</div>
<div class="line"> </div>
<div class="line">    turtlesim_node = Node(</div>
<div class="line">        package=&#39;turtlesim&#39;,</div>
<div class="line">        namespace=turtlesim_ns,</div>
<div class="line">        executable=&#39;turtlesim_node&#39;,</div>
<div class="line">        name=&#39;sim&#39;</div>
<div class="line">    )</div>
<div class="line">    spawn_turtle = ExecuteProcess(</div>
<div class="line">        cmd=[[</div>
<div class="line">            &#39;ros2 service call &#39;,</div>
<div class="line">            turtlesim_ns,</div>
<div class="line">            &#39;/spawn &#39;,</div>
<div class="line">            &#39;turtlesim/srv/Spawn &#39;,</div>
<div class="line">            &#39;&quot;{x: 2, y: 2, theta: 0.2}&quot;&#39;</div>
<div class="line">        ]],</div>
<div class="line">        shell=True</div>
<div class="line">    )</div>
<div class="line">    change_background_r = ExecuteProcess(</div>
<div class="line">        cmd=[[</div>
<div class="line">            &#39;ros2 param set &#39;,</div>
<div class="line">            turtlesim_ns,</div>
<div class="line">            &#39;/sim background_r &#39;,</div>
<div class="line">            &#39;120&#39;</div>
<div class="line">        ]],</div>
<div class="line">        shell=True</div>
<div class="line">    )</div>
<div class="line">    change_background_r_conditioned = ExecuteProcess(</div>
<div class="line">        condition=IfCondition(</div>
<div class="line">            PythonExpression([</div>
<div class="line">                new_background_r,</div>
<div class="line">                &#39; == 200&#39;,</div>
<div class="line">                &#39; and &#39;,</div>
<div class="line">                use_provided_red</div>
<div class="line">            ])</div>
<div class="line">        ),</div>
<div class="line">        cmd=[[</div>
<div class="line">            &#39;ros2 param set &#39;,</div>
<div class="line">            turtlesim_ns,</div>
<div class="line">            &#39;/sim background_r &#39;,</div>
<div class="line">            new_background_r</div>
<div class="line">        ]],</div>
<div class="line">        shell=True</div>
<div class="line">    )</div>
<div class="line"> </div>
<div class="line">    return LaunchDescription([</div>
<div class="line">        turtlesim_ns_launch_arg,</div>
<div class="line">        use_provided_red_launch_arg,</div>
<div class="line">        new_background_r_launch_arg,</div>
<div class="line">        turtlesim_node,</div>
<div class="line">        spawn_turtle,</div>
<div class="line">        change_background_r,</div>
<div class="line">        TimerAction(</div>
<div class="line">            period=2.0,</div>
<div class="line">            actions=[change_background_r_conditioned],</div>
<div class="line">        )</div>
<div class="line">    ])</div>
</div><!-- fragment --><p>Then, as always, build it, source it. </p><div class="fragment"><div class="line">colcon build</div>
<div class="line">source install/setup.bash</div>
</div><!-- fragment --><p> However, I ran into a some issues while building it. Here's the error message: </p><div class="fragment"><div class="line">/usr/lib/python3/dist-packages/setuptools/command/install.py:34: SetuptoolsDeprecationWarning: setup.py install is deprecated.</div>
</div><!-- fragment --><p> I googled it <a href="https://answers.ros.org/question/396439/setuptoolsdeprecationwarning-setuppy-install-is-deprecated-use-build-and-pip-and-other-standards-based-tools/">here</a> and turns out that the setuptools package was too new. The original version I had was 59.6.0, but the last available version was 58.2.0. So that I <code>pip3 install setuptools==58.2.0</code>, and source the setup files again. After that, the build was done successfully.</p>
<p>Finally, we can launch it: </p><div class="fragment"><div class="line">ros2 launch launch_tutorial example_main.launch.py</div>
</div><!-- fragment --><p> (quoted from the tutorial) Then the following four things would happen:</p><ol type="1">
<li>Start a turtlesim node with a blue background</li>
<li>Spawn the second turtle</li>
<li>Change the color to purple</li>
<li>Change the color to pink after two seconds if the provided <code>background_r</code> argument is 200 and <code>use_provided_red</code> argument is <code>True</code></li>
</ol>
<p>We can also modify launch arguments that isn't neccessarily defined in the launch file and could be done in the command line. The following command would show the arguments </p><div class="fragment"><div class="line">ros2 launch launch_tutorial example_substitutions.launch.py --show-args</div>
</div><!-- fragment --><p> And it would return the argument configurations: </p><div class="fragment"><div class="line">Arguments (pass arguments as &#39;&lt;name&gt;:=&lt;value&gt;&#39;):</div>
<div class="line"> </div>
<div class="line">    &#39;turtlesim_ns&#39;:</div>
<div class="line">        no description given</div>
<div class="line">        (default: &#39;turtlesim1&#39;)</div>
<div class="line"> </div>
<div class="line">    &#39;use_provided_red&#39;:</div>
<div class="line">        no description given</div>
<div class="line">        (default: &#39;False&#39;)</div>
<div class="line"> </div>
<div class="line">    &#39;new_background_r&#39;:</div>
<div class="line">        no description given</div>
<div class="line">        (default: &#39;200&#39;)</div>
</div><!-- fragment --><p> Which correspond with the code in <code>example_substitutions.launch.py</code>: </p><div class="fragment"><div class="line">turtlesim_ns_launch_arg = DeclareLaunchArgument(</div>
<div class="line">    &#39;turtlesim_ns&#39;,</div>
<div class="line">    default_value=&#39;turtlesim1&#39;</div>
<div class="line">)</div>
<div class="line">use_provided_red_launch_arg = DeclareLaunchArgument(</div>
<div class="line">    &#39;use_provided_red&#39;,</div>
<div class="line">    default_value=&#39;False&#39;</div>
<div class="line">)</div>
<div class="line">new_background_r_launch_arg = DeclareLaunchArgument(</div>
<div class="line">    &#39;new_background_r&#39;,</div>
<div class="line">    default_value=&#39;200&#39;</div>
<div class="line">)</div>
</div><!-- fragment --><p> And we can modify those argument setups by: </p><div class="fragment"><div class="line">ros2 launch launch_tutorial example_substitutions.launch.py turtlesim_ns:=&#39;turtlesim3&#39; use_provided_red:=&#39;True&#39; new_background_r:=200</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md166"></a>
Using Event Handler</h3>
<blockquote class="doxtable">
<p><b>Launch in ROS 2 is a system that executes and manages user-defined processes. It is responsible for monitoring the state of processes it launched, as well as reporting and reacting to changes in the state of those processes. These changes are called events and can be handled by registering an event handler with the launch system. Event handlers can be registered for specific events and can be useful for monitoring the state of processes. Additionally, they can be used to define a complex set of rules which can be used to dynamically modify the launch file.</b> </p>
</blockquote>
<p>In the package <code>launch_tutorial</code>, create a file <code>example_event_handlers.launch.py</code> in <code>launch</code>. </p><div class="fragment"><div class="line">from launch_ros.actions import Node</div>
<div class="line"> </div>
<div class="line">from launch import LaunchDescription</div>
<div class="line">from launch.actions import (DeclareLaunchArgument, EmitEvent, ExecuteProcess,</div>
<div class="line">                            LogInfo, RegisterEventHandler, TimerAction)</div>
<div class="line">from launch.conditions import IfCondition</div>
<div class="line">from launch.event_handlers import (OnExecutionComplete, OnProcessExit,</div>
<div class="line">                                OnProcessIO, OnProcessStart, OnShutdown)</div>
<div class="line">from launch.events import Shutdown</div>
<div class="line">from launch.substitutions import (EnvironmentVariable, FindExecutable,</div>
<div class="line">                                LaunchConfiguration, LocalSubstitution,</div>
<div class="line">                                PythonExpression)</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">def generate_launch_description():</div>
<div class="line">    turtlesim_ns = LaunchConfiguration(&#39;turtlesim_ns&#39;)</div>
<div class="line">    use_provided_red = LaunchConfiguration(&#39;use_provided_red&#39;)</div>
<div class="line">    new_background_r = LaunchConfiguration(&#39;new_background_r&#39;)</div>
<div class="line"> </div>
<div class="line">    turtlesim_ns_launch_arg = DeclareLaunchArgument(</div>
<div class="line">        &#39;turtlesim_ns&#39;,</div>
<div class="line">        default_value=&#39;turtlesim1&#39;</div>
<div class="line">    )</div>
<div class="line">    use_provided_red_launch_arg = DeclareLaunchArgument(</div>
<div class="line">        &#39;use_provided_red&#39;,</div>
<div class="line">        default_value=&#39;False&#39;</div>
<div class="line">    )</div>
<div class="line">    new_background_r_launch_arg = DeclareLaunchArgument(</div>
<div class="line">        &#39;new_background_r&#39;,</div>
<div class="line">        default_value=&#39;200&#39;</div>
<div class="line">    )</div>
<div class="line"> </div>
<div class="line">    turtlesim_node = Node(</div>
<div class="line">        package=&#39;turtlesim&#39;,</div>
<div class="line">        namespace=turtlesim_ns,</div>
<div class="line">        executable=&#39;turtlesim_node&#39;,</div>
<div class="line">        name=&#39;sim&#39;</div>
<div class="line">    )</div>
<div class="line">    spawn_turtle = ExecuteProcess(</div>
<div class="line">        cmd=[[</div>
<div class="line">            FindExecutable(name=&#39;ros2&#39;),</div>
<div class="line">            &#39; service call &#39;,</div>
<div class="line">            turtlesim_ns,</div>
<div class="line">            &#39;/spawn &#39;,</div>
<div class="line">            &#39;turtlesim/srv/Spawn &#39;,</div>
<div class="line">            &#39;&quot;{x: 2, y: 2, theta: 0.2}&quot;&#39;</div>
<div class="line">        ]],</div>
<div class="line">        shell=True</div>
<div class="line">    )</div>
<div class="line">    change_background_r = ExecuteProcess(</div>
<div class="line">        cmd=[[</div>
<div class="line">            FindExecutable(name=&#39;ros2&#39;),</div>
<div class="line">            &#39; param set &#39;,</div>
<div class="line">            turtlesim_ns,</div>
<div class="line">            &#39;/sim background_r &#39;,</div>
<div class="line">            &#39;120&#39;</div>
<div class="line">        ]],</div>
<div class="line">        shell=True</div>
<div class="line">    )</div>
<div class="line">    change_background_r_conditioned = ExecuteProcess(</div>
<div class="line">        condition=IfCondition(</div>
<div class="line">            PythonExpression([</div>
<div class="line">                new_background_r,</div>
<div class="line">                &#39; == 200&#39;,</div>
<div class="line">                &#39; and &#39;,</div>
<div class="line">                use_provided_red</div>
<div class="line">            ])</div>
<div class="line">        ),</div>
<div class="line">        cmd=[[</div>
<div class="line">            FindExecutable(name=&#39;ros2&#39;),</div>
<div class="line">            &#39; param set &#39;,</div>
<div class="line">            turtlesim_ns,</div>
<div class="line">            &#39;/sim background_r &#39;,</div>
<div class="line">            new_background_r</div>
<div class="line">        ]],</div>
<div class="line">        shell=True</div>
<div class="line">    )</div>
<div class="line"> </div>
<div class="line">    return LaunchDescription([</div>
<div class="line">        turtlesim_ns_launch_arg,</div>
<div class="line">        use_provided_red_launch_arg,</div>
<div class="line">        new_background_r_launch_arg,</div>
<div class="line">        turtlesim_node,</div>
<div class="line">        RegisterEventHandler(</div>
<div class="line">            OnProcessStart(</div>
<div class="line">                target_action=turtlesim_node,</div>
<div class="line">                on_start=[</div>
<div class="line">                    LogInfo(msg=&#39;Turtlesim started, spawning turtle&#39;),</div>
<div class="line">                    spawn_turtle</div>
<div class="line">                ]</div>
<div class="line">            )</div>
<div class="line">        ),</div>
<div class="line">        RegisterEventHandler(</div>
<div class="line">            OnProcessIO(</div>
<div class="line">                target_action=spawn_turtle,</div>
<div class="line">                on_stdout=lambda event: LogInfo(</div>
<div class="line">                    msg=&#39;Spawn request says &quot;{}&quot;&#39;.format(</div>
<div class="line">                        event.text.decode().strip())</div>
<div class="line">                )</div>
<div class="line">            )</div>
<div class="line">        ),</div>
<div class="line">        RegisterEventHandler(</div>
<div class="line">            OnExecutionComplete(</div>
<div class="line">                target_action=spawn_turtle,</div>
<div class="line">                on_completion=[</div>
<div class="line">                    LogInfo(msg=&#39;Spawn finished&#39;),</div>
<div class="line">                    change_background_r,</div>
<div class="line">                    TimerAction(</div>
<div class="line">                        period=2.0,</div>
<div class="line">                        actions=[change_background_r_conditioned],</div>
<div class="line">                    )</div>
<div class="line">                ]</div>
<div class="line">            )</div>
<div class="line">        ),</div>
<div class="line">        RegisterEventHandler(</div>
<div class="line">            OnProcessExit(</div>
<div class="line">                target_action=turtlesim_node,</div>
<div class="line">                on_exit=[</div>
<div class="line">                    LogInfo(msg=(EnvironmentVariable(name=&#39;USER&#39;),</div>
<div class="line">                            &#39; closed the turtlesim window&#39;)),</div>
<div class="line">                    EmitEvent(event=Shutdown(</div>
<div class="line">                        reason=&#39;Window closed&#39;))</div>
<div class="line">                ]</div>
<div class="line">            )</div>
<div class="line">        ),</div>
<div class="line">        RegisterEventHandler(</div>
<div class="line">            OnShutdown(</div>
<div class="line">                on_shutdown=[LogInfo(</div>
<div class="line">                    msg=[&#39;Launch was asked to shutdown: &#39;,</div>
<div class="line">                        LocalSubstitution(&#39;event.reason&#39;)]</div>
<div class="line">                )]</div>
<div class="line">            )</div>
<div class="line">        ),</div>
<div class="line">    ])</div>
</div><!-- fragment --><p>The <code>RegisterEventHandler()</code> would register event handlers, which are a few actions, such as OnProcessStart, OnProcessIO, OnExecutionComplete, OnProcessExit, and OnShutdown. The events were defined in the description.</p>
<p>After that, build it, source it, then run it. </p><div class="fragment"><div class="line">colcon build</div>
<div class="line">source install/setup.bash</div>
<div class="line">ros2 launch launch_tutorial example_event_handlers.launch.py turtlesim_ns:=&#39;turtlesim3&#39; use_provided_red:=&#39;True&#39; new_background_r:=200</div>
</div><!-- fragment --><p> (remember that these are argument setups)</p>
<p><img src="/ntu_racing_hw/ros2_setup/pictures/Screenshot%202023-09-08%20082025.png" alt="" class="inline"/> The log infos: </p><div class="fragment"><div class="line">[INFO] [launch]: All log files can be found below /home/docker/.ros/log/2023-09-08-08-19-47-605832-ros2-210</div>
<div class="line">[INFO] [launch]: Default logging verbosity is set to INFO</div>
<div class="line">[INFO] [turtlesim_node-1]: process started with pid [211]</div>
<div class="line">[INFO] [launch.user]: Turtlesim started, spawning turtle #</div>
<div class="line">[INFO] [Spawn &quot;{x: 2, y: 2, theta: 0.2}&quot;-2]: process started with pid [213]</div>
<div class="line">[turtlesim_node-1] QStandardPaths: XDG_RUNTIME_DIR not set, defaulting to &#39;/tmp/runtime-docker&#39;</div>
<div class="line">[turtlesim_node-1] [INFO] [1694132390.797659651] [turtlesim3.sim]: Starting turtlesim with node name /turtlesim3/sim</div>
<div class="line">[turtlesim_node-1] [INFO] [1694132390.922368520] [turtlesim3.sim]: Spawning turtle [turtle1] at x=[5.544445], y=[5.544445], theta=[0.000000]</div>
<div class="line">[INFO] [launch.user]: Spawn request says &quot;requester: making request: turtlesim.srv.Spawn_Request(x=2.0, y=2.0, theta=0.2, name=&#39;&#39;)&quot; #</div>
<div class="line">[turtlesim_node-1] [INFO] [1694132394.946573205] [turtlesim3.sim]: Spawning turtle [turtle2] at x=[2.000000], y=[2.000000], theta=[0.200000]</div>
<div class="line">[INFO] [launch.user]: Spawn request says &quot;response: #</div>
<div class="line">turtlesim.srv.Spawn_Response(name=&#39;turtle2&#39;)&quot;</div>
<div class="line">[INFO] [Spawn &quot;{x: 2, y: 2, theta: 0.2}&quot;-2]: process has finished cleanly [pid 213]</div>
<div class="line">[INFO] [launch.user]: Spawn finished #</div>
<div class="line">[INFO] [sim background_r 120-3]: process started with pid [250]</div>
<div class="line">[INFO] [sim background_r 200-4]: process started with pid [253]</div>
<div class="line">[INFO] [sim background_r 120-3]: process has finished cleanly [pid 250]</div>
<div class="line">[INFO] [sim background_r 200-4]: process has finished cleanly [pid 253]</div>
<div class="line">[INFO] [turtlesim_node-1]: process has finished cleanly [pid 211]</div>
<div class="line">[INFO] [launch.user]: docker closed the turtlesim window #</div>
<div class="line">[INFO] [launch.user]: Launch was asked to shutdown: Window closed #</div>
</div><!-- fragment --><p> (quoted from the tutorial)</p>
<p>This will do the following:</p><ol type="1">
<li>Start a turtlesim node with a blue background</li>
<li>Spawn the second turtle</li>
<li>Change the color to purple</li>
<li>Change the color to pink after two seconds if the provided background_r argument is 200 and use_provided_red argument is True</li>
<li>Shutdown the launch file when the turtlesim window is closed</li>
</ol>
<p>Additionally, it will log messages to the console when:</p><ol type="1">
<li>The turtlesim node starts</li>
<li>The spawn action is executed</li>
<li>The change_background_r action is executed</li>
<li>The change_background_r_conditioned action is executed</li>
<li>The turtlesim node exits</li>
<li>The launch process is asked to shutdown.</li>
</ol>
<h3><a class="anchor" id="autotoc_md167"></a>
Managing large projects</h3>
<blockquote class="doxtable">
<p>This tutorial describes some tips for writing launch files for large projects. <b>The focus is on how to structure launch files so they may be reused as much as possible in different situations</b>. Additionally, it covers usage examples of different ROS 2 launch tools, like parameters, YAML files, remappings, namespaces, default arguments, and RViz configs. </p>
</blockquote>
<p>This tutorial is using turtle_tf2_py package, so we should install that before getting started </p><div class="fragment"><div class="line">sudo apt-get install ros-humble-turtle-tf2-py</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md168"></a>
Top Level organization</h4>
<p>Running ROS2 in a robot may involve many nodes which are responsible for many different tasks. So we're simulating that circumstance with multiple nodes related to turtlesim.</p>
<p>First, we go through the <b>top level</b> launch file structure, create <code>launch_turtlesim.launch.py</code> under <code>launch</code> directory: </p><div class="fragment"><div class="line">import os</div>
<div class="line"> </div>
<div class="line">from ament_index_python.packages import get_package_share_directory</div>
<div class="line"> </div>
<div class="line">from launch import LaunchDescription</div>
<div class="line">from launch.actions import IncludeLaunchDescription</div>
<div class="line">from launch.launch_description_sources import PythonLaunchDescriptionSource</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">def generate_launch_description():</div>
<div class="line">   turtlesim_world_1 = IncludeLaunchDescription(</div>
<div class="line">      PythonLaunchDescriptionSource([os.path.join(</div>
<div class="line">         get_package_share_directory(&#39;launch_tutorial&#39;), &#39;launch&#39;),</div>
<div class="line">         &#39;/turtlesim_world_1.launch.py&#39;])</div>
<div class="line">      )</div>
<div class="line">   turtlesim_world_2 = IncludeLaunchDescription(</div>
<div class="line">      PythonLaunchDescriptionSource([os.path.join(</div>
<div class="line">         get_package_share_directory(&#39;launch_tutorial&#39;), &#39;launch&#39;),</div>
<div class="line">         &#39;/turtlesim_world_2.launch.py&#39;])</div>
<div class="line">      )</div>
<div class="line">   broadcaster_listener_nodes = IncludeLaunchDescription(</div>
<div class="line">      PythonLaunchDescriptionSource([os.path.join(</div>
<div class="line">         get_package_share_directory(&#39;launch_tutorial&#39;), &#39;launch&#39;),</div>
<div class="line">         &#39;/broadcaster_listener.launch.py&#39;]),</div>
<div class="line">      launch_arguments={&#39;target_frame&#39;: &#39;carrot1&#39;}.items(),</div>
<div class="line">      )</div>
<div class="line">   mimic_node = IncludeLaunchDescription(</div>
<div class="line">      PythonLaunchDescriptionSource([os.path.join(</div>
<div class="line">         get_package_share_directory(&#39;launch_tutorial&#39;), &#39;launch&#39;),</div>
<div class="line">         &#39;/mimic.launch.py&#39;])</div>
<div class="line">      )</div>
<div class="line">   fixed_frame_node = IncludeLaunchDescription(</div>
<div class="line">      PythonLaunchDescriptionSource([os.path.join(</div>
<div class="line">         get_package_share_directory(&#39;launch_tutorial&#39;), &#39;launch&#39;),</div>
<div class="line">         &#39;/fixed_broadcaster.launch.py&#39;])</div>
<div class="line">      )</div>
<div class="line">   rviz_node = IncludeLaunchDescription(</div>
<div class="line">      PythonLaunchDescriptionSource([os.path.join(</div>
<div class="line">         get_package_share_directory(&#39;launch_tutorial&#39;), &#39;launch&#39;),</div>
<div class="line">         &#39;/turtlesim_rviz.launch.py&#39;])</div>
<div class="line">      )</div>
<div class="line"> </div>
<div class="line">   return LaunchDescription([</div>
<div class="line">      turtlesim_world_1,</div>
<div class="line">      turtlesim_world_2,</div>
<div class="line">      broadcaster_listener_nodes,</div>
<div class="line">      mimic_node,</div>
<div class="line">      fixed_frame_node,</div>
<div class="line">      rviz_node</div>
<div class="line">   ])</div>
</div><!-- fragment --><p> (quoted from the tutorial)</p><ul>
<li>This launch file includes a set of other launch files. Each of these included launch files contains nodes, parameters, and possibly, nested includes, which pertain to one part of the system. To be exact, we launch two turtlesim simulation worlds, TF broadcaster, TF listener, mimic, fixed frame broadcaster, and RViz nodes.</li>
<li>The top-level launch file should be short. Details are included by the low-level launch files. However, we should be aware of the tradeoffs.</li>
</ul>
<h4><a class="anchor" id="autotoc_md169"></a>
Parameters</h4>
<p>Now, we should set parameters in the launch file structure, so create <code>turtlesim_world_1.launch.py</code>: </p><div class="fragment"><div class="line">from launch import LaunchDescription</div>
<div class="line">from launch.actions import DeclareLaunchArgument</div>
<div class="line">from launch.substitutions import LaunchConfiguration, TextSubstitution</div>
<div class="line"> </div>
<div class="line">from launch_ros.actions import Node</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">def generate_launch_description():</div>
<div class="line">   background_r_launch_arg = DeclareLaunchArgument(</div>
<div class="line">      &#39;background_r&#39;, default_value=TextSubstitution(text=&#39;0&#39;)</div>
<div class="line">   )</div>
<div class="line">   background_g_launch_arg = DeclareLaunchArgument(</div>
<div class="line">      &#39;background_g&#39;, default_value=TextSubstitution(text=&#39;84&#39;)</div>
<div class="line">   )</div>
<div class="line">   background_b_launch_arg = DeclareLaunchArgument(</div>
<div class="line">      &#39;background_b&#39;, default_value=TextSubstitution(text=&#39;122&#39;)</div>
<div class="line">   )</div>
<div class="line"> </div>
<div class="line">   return LaunchDescription([</div>
<div class="line">      background_r_launch_arg,</div>
<div class="line">      background_g_launch_arg,</div>
<div class="line">      background_b_launch_arg,</div>
<div class="line">      Node(</div>
<div class="line">         package=&#39;turtlesim&#39;,</div>
<div class="line">         executable=&#39;turtlesim_node&#39;,</div>
<div class="line">         name=&#39;sim&#39;,</div>
<div class="line">         parameters=[{</div>
<div class="line">            &#39;background_r&#39;: LaunchConfiguration(&#39;background_r&#39;),</div>
<div class="line">            &#39;background_g&#39;: LaunchConfiguration(&#39;background_g&#39;),</div>
<div class="line">            &#39;background_b&#39;: LaunchConfiguration(&#39;background_b&#39;),</div>
<div class="line">         }]</div>
<div class="line">      ),</div>
<div class="line">   ])</div>
</div><!-- fragment --><p> The code above launches a turtlesim node simulation, with configuration parameters defined and passed to it.</p>
<p>Now, we want to create another turtlesim simulation, so create <code>turtlesim_world_2.launch.py</code>: </p><div class="fragment"><div class="line">import os</div>
<div class="line"> </div>
<div class="line">from ament_index_python.packages import get_package_share_directory</div>
<div class="line"> </div>
<div class="line">from launch import LaunchDescription</div>
<div class="line">from launch_ros.actions import Node</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">def generate_launch_description():</div>
<div class="line">   config = os.path.join(</div>
<div class="line">      get_package_share_directory(&#39;launch_tutorial&#39;),</div>
<div class="line">      &#39;config&#39;,</div>
<div class="line">      &#39;turtlesim.yaml&#39;</div>
<div class="line">      )</div>
<div class="line"> </div>
<div class="line">   return LaunchDescription([</div>
<div class="line">      Node(</div>
<div class="line">         package=&#39;turtlesim&#39;,</div>
<div class="line">         executable=&#39;turtlesim_node&#39;,</div>
<div class="line">         namespace=&#39;turtlesim2&#39;,</div>
<div class="line">         name=&#39;sim&#39;,</div>
<div class="line">         parameters=[config]</div>
<div class="line">      )</div>
<div class="line">   ])</div>
</div><!-- fragment --><p> This would load the configuration parameters directly from the <code>turtlesim.yaml</code> file. With <code>yaml</code> files, it's easier to manage large configuration set of parameters. In addition, <code>yaml</code> files can be easily exported from the current ros2 param list. So now we create a directory <code>config</code> in our package, then create <code>turtlesim.yaml</code> inside. </p><div class="fragment"><div class="line">/turtlesim2/sim:</div>
<div class="line">   ros__parameters:</div>
<div class="line">      background_b: 255</div>
<div class="line">      background_g: 86</div>
<div class="line">      background_r: 150</div>
</div><!-- fragment --><p>However, that set of configuration parameters are only for the node <code>sim</code> in the <code>turtlesim2</code> namespace. What if we want to set these config parameters to multiple nodes in different namespaces? We can use the <b>wildcard</b> syntax -&gt; <code>/**</code>. In this way, all the launch files include this <code>yaml</code> file could apply this set of parameters. Thus, we could change <code>turtlesim.yaml</code> to: </p><div class="fragment"><div class="line">/**:</div>
<div class="line">   ros__parameters:</div>
<div class="line">      background_b: 255</div>
<div class="line">      background_g: 86</div>
<div class="line">      background_r: 150</div>
</div><!-- fragment --><p> Also, create <code>turtlesim_world_3.launch.py</code> which could demonstrate this syntax: </p><div class="fragment"><div class="line"># same as turtlesim_world_2.launch.py but just add another node</div>
<div class="line">Node(</div>
<div class="line">   package=&#39;turtlesim&#39;,</div>
<div class="line">   executable=&#39;turtlesim_node&#39;,</div>
<div class="line">   namespace=&#39;turtlesim3&#39;,</div>
<div class="line">   name=&#39;sim&#39;,</div>
<div class="line">   parameters=[config]</div>
<div class="line">)</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md170"></a>
Namespaces</h4>
<p>(quoted from the tutorial) Using unique namespaces allow the system to start two similar nodes without node name or topic name conflicts. However, if the launch file contains a large number of nodes, defining namespaces for each of them can become tedious. To solve that issue, <b>the <code>PushRosNamespace</code> action can be used to define the global namespace for each launch file description. Every nested node will inherit that namespace automatically.</b></p>
<p>First, remove the namespace specification <code>namespace='turtlesim2'</code> from the launch file first. Then, in the top-level launch file <code>launch_turtlesim.launch.py</code>, add: </p><div class="fragment"><div class="line">from launch.actions import GroupAction</div>
<div class="line">from launch_ros.actions import PushRosNamespace</div>
<div class="line"> </div>
<div class="line">   ...</div>
<div class="line">   turtlesim_world_2 = IncludeLaunchDescription(</div>
<div class="line">      PythonLaunchDescriptionSource([os.path.join(</div>
<div class="line">         get_package_share_directory(&#39;launch_tutorial&#39;), &#39;launch&#39;),</div>
<div class="line">         &#39;/turtlesim_world_2.launch.py&#39;])</div>
<div class="line">      )</div>
<div class="line">   turtlesim_world_2_with_namespace = GroupAction(</div>
<div class="line">     actions=[</div>
<div class="line">         PushRosNamespace(&#39;turtlesim2&#39;),</div>
<div class="line">         turtlesim_world_2,</div>
<div class="line">      ]</div>
<div class="line">   )</div>
</div><!-- fragment --><p> Replace <code>turtlesim_world_2</code> with <code>turtlesim_world_2_with_namespace</code> which has PushRosNamespace in the first place.</p>
<h4><a class="anchor" id="autotoc_md171"></a>
Reusing the nodes</h4>
<p>Create a launch file <code>broadcaster_listener.launch.py</code>: </p><div class="fragment"><div class="line">from launch import LaunchDescription</div>
<div class="line">from launch.actions import DeclareLaunchArgument</div>
<div class="line">from launch.substitutions import LaunchConfiguration</div>
<div class="line"> </div>
<div class="line">from launch_ros.actions import Node</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">def generate_launch_description():</div>
<div class="line">   return LaunchDescription([</div>
<div class="line">      DeclareLaunchArgument(</div>
<div class="line">         &#39;target_frame&#39;, default_value=&#39;turtle1&#39;,</div>
<div class="line">         description=&#39;Target frame name.&#39;</div>
<div class="line">      ),</div>
<div class="line">      Node(</div>
<div class="line">         package=&#39;turtle_tf2_py&#39;,</div>
<div class="line">         executable=&#39;turtle_tf2_broadcaster&#39;,</div>
<div class="line">         name=&#39;broadcaster1&#39;,</div>
<div class="line">         parameters=[</div>
<div class="line">            {&#39;turtlename&#39;: &#39;turtle1&#39;}</div>
<div class="line">         ]</div>
<div class="line">      ),</div>
<div class="line">      Node(</div>
<div class="line">         package=&#39;turtle_tf2_py&#39;,</div>
<div class="line">         executable=&#39;turtle_tf2_broadcaster&#39;,</div>
<div class="line">         name=&#39;broadcaster2&#39;,</div>
<div class="line">         parameters=[</div>
<div class="line">            {&#39;turtlename&#39;: &#39;turtle2&#39;}</div>
<div class="line">         ]</div>
<div class="line">      ),</div>
<div class="line">      Node(</div>
<div class="line">         package=&#39;turtle_tf2_py&#39;,</div>
<div class="line">         executable=&#39;turtle_tf2_listener&#39;,</div>
<div class="line">         name=&#39;listener&#39;,</div>
<div class="line">         parameters=[</div>
<div class="line">            {&#39;target_frame&#39;: LaunchConfiguration(&#39;target_frame&#39;)}</div>
<div class="line">         ]</div>
<div class="line">      ),</div>
<div class="line">   ])</div>
</div><!-- fragment --><p>We can reuse the nodes by giving them different names. In the above launch file, we've declared a launch argument <code>target_frame</code>. The argument would be passed to the node, and default value is set to 'turtle1'.</p>
<p>We can override the parameters. In the top level launch file, we've called the <code>broadcaster_listener.launch.py</code> file. We've passed that launch file <code>target_frame</code> launch argument as shown below: </p><div class="fragment"><div class="line">broadcaster_listener_nodes = IncludeLaunchDescription(</div>
<div class="line">   PythonLaunchDescriptionSource([os.path.join(</div>
<div class="line">      get_package_share_directory(&#39;launch_tutorial&#39;), &#39;launch&#39;),</div>
<div class="line">      &#39;/broadcaster_listener.launch.py&#39;]),</div>
<div class="line">   launch_arguments={&#39;target_frame&#39;: &#39;carrot1&#39;}.items(),</div>
<div class="line">   )</div>
</div><!-- fragment --><p> The default goal target frame is changed to <code>carrot1</code>. If we want to use that default value <code>turtle1</code>, just remove that line.</p>
<h4><a class="anchor" id="autotoc_md172"></a>
Remapping</h4>
<p>Create a file <code>mimic.launch.py</code>: </p><div class="fragment"><div class="line">from launch import LaunchDescription</div>
<div class="line">from launch_ros.actions import Node</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">def generate_launch_description():</div>
<div class="line">   return LaunchDescription([</div>
<div class="line">      Node(</div>
<div class="line">         package=&#39;turtlesim&#39;,</div>
<div class="line">         executable=&#39;mimic&#39;,</div>
<div class="line">         name=&#39;mimic&#39;,</div>
<div class="line">         remappings=[</div>
<div class="line">            (&#39;/input/pose&#39;, &#39;/turtle2/pose&#39;),</div>
<div class="line">            (&#39;/output/cmd_vel&#39;, &#39;/turtlesim2/turtle1/cmd_vel&#39;),</div>
<div class="line">         ]</div>
<div class="line">      )</div>
<div class="line">   ])</div>
</div><!-- fragment --><p>This would start a node called mimic using an executable <code>mimic</code> in package <code>turtlesim</code>. Then, we want to remap the topic <code>/input/pose</code> of mimic to <code>/turtle2/pose</code> of turtle2, and remap <code>/output/cmd_vel</code> of mimic to <code>/turtlesim2/turtle1/cmd_vel</code> of turtle1. This would pass the pose of turtle2, to the mimic node, and the mimic node would pass the message to the turtle1, resulting in turtle1 mimicing turtle2.</p>
<h4><a class="anchor" id="autotoc_md173"></a>
Config files</h4>
<p>Create a file <code>turtlesim_rviz.launch.py</code>: </p><div class="fragment"><div class="line">import os</div>
<div class="line"> </div>
<div class="line">from ament_index_python.packages import get_package_share_directory</div>
<div class="line"> </div>
<div class="line">from launch import LaunchDescription</div>
<div class="line">from launch_ros.actions import Node</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">def generate_launch_description():</div>
<div class="line">   rviz_config = os.path.join(</div>
<div class="line">      get_package_share_directory(&#39;turtle_tf2_py&#39;),</div>
<div class="line">      &#39;rviz&#39;,</div>
<div class="line">      &#39;turtle_rviz.rviz&#39;</div>
<div class="line">      )</div>
<div class="line"> </div>
<div class="line">   return LaunchDescription([</div>
<div class="line">      Node(</div>
<div class="line">         package=&#39;rviz2&#39;,</div>
<div class="line">         executable=&#39;rviz2&#39;,</div>
<div class="line">         name=&#39;rviz2&#39;,</div>
<div class="line">         arguments=[&#39;-d&#39;, rviz_config]</div>
<div class="line">      )</div>
<div class="line">   ])</div>
</div><!-- fragment --><p> What is RViz? It's a 3d visualization tool for ROS. <a href="http://wiki.ros.org/rviz">About RViz</a></p>
<p>(quoted from tutorial) This launch file will start the RViz with the configuration file defined in the turtle_tf2_py package. This RViz configuration will set the world frame, enable TF visualization, and start RViz with a top-down view.</p>
<h4><a class="anchor" id="autotoc_md174"></a>
Environment Variables</h4>
<p>Create a launch file <code>fixed_broadcaster.launch.py</code>: </p><div class="fragment"><div class="line">from launch import LaunchDescription</div>
<div class="line">from launch.actions import DeclareLaunchArgument</div>
<div class="line">from launch.substitutions import EnvironmentVariable, LaunchConfiguration</div>
<div class="line">from launch_ros.actions import Node</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">def generate_launch_description():</div>
<div class="line">   return LaunchDescription([</div>
<div class="line">      DeclareLaunchArgument(</div>
<div class="line">            &#39;node_prefix&#39;,</div>
<div class="line">            default_value=[EnvironmentVariable(&#39;USER&#39;), &#39;_&#39;],</div>
<div class="line">            description=&#39;prefix for node name&#39;</div>
<div class="line">      ),</div>
<div class="line">      Node(</div>
<div class="line">            package=&#39;turtle_tf2_py&#39;,</div>
<div class="line">            executable=&#39;fixed_frame_tf2_broadcaster&#39;,</div>
<div class="line">            name=[LaunchConfiguration(&#39;node_prefix&#39;), &#39;fixed_broadcaster&#39;],</div>
<div class="line">      ),</div>
<div class="line">   ])</div>
</div><!-- fragment --> <blockquote class="doxtable">
<p>This launch file shows the way environment variables can be called inside the launch files. Environment variables can be used to define or push namespaces for distinguishing nodes on different computers or robots. </p>
</blockquote>
<h4><a class="anchor" id="autotoc_md175"></a>
Run the launch files</h4>
<p>Finally we can start running the launch files. Before we start, modify the setup.py file to include all the launch <code>.py</code> files and the configuration <code>.yaml</code> files: </p><div class="fragment"><div class="line">import os</div>
<div class="line">from glob import glob</div>
<div class="line">from setuptools import setup</div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">data_files=[</div>
<div class="line">      ...</div>
<div class="line">      (os.path.join(&#39;share&#39;, package_name, &#39;launch&#39;),</div>
<div class="line">         glob(os.path.join(&#39;launch&#39;, &#39;*.launch.py&#39;))),</div>
<div class="line">      (os.path.join(&#39;share&#39;, package_name, &#39;config&#39;),</div>
<div class="line">         glob(os.path.join(&#39;config&#39;, &#39;*.yaml&#39;))),</div>
<div class="line">   ],</div>
</div><!-- fragment --><p>Then, build it, source it, and run it: </p><div class="fragment"><div class="line">colcon build</div>
<div class="line">source install/setup.bash</div>
<div class="line">ros2 launch launch_tutorial launch_turtlesim.launch.py</div>
</div><!-- fragment --><p> (remember to download the rviz package): </p><div class="fragment"><div class="line">sudo apt-get install ros-humble-rviz2</div>
</div><!-- fragment --><p> Here's the log message: </p><div class="fragment"><div class="line">docker@ros2:~/ws/src/launch_ws$ ros2 launch launch_tutorial launch_turtlesim.launch.py</div>
<div class="line">[INFO] [launch]: All log files can be found below /home/docker/.ros/log/2023-09-08-16-31-25-842726-ros2-982</div>
<div class="line">[INFO] [launch]: Default logging verbosity is set to INFO</div>
<div class="line">[INFO] [turtlesim_node-1]: process started with pid [983]</div>
<div class="line">[INFO] [turtlesim_node-2]: process started with pid [985]</div>
<div class="line">[INFO] [turtle_tf2_broadcaster-3]: process started with pid [987]</div>
<div class="line">[INFO] [turtle_tf2_broadcaster-4]: process started with pid [989]</div>
<div class="line">[INFO] [turtle_tf2_listener-5]: process started with pid [991]</div>
<div class="line">[INFO] [mimic-6]: process started with pid [993]</div>
<div class="line">[INFO] [fixed_frame_tf2_broadcaster-7]: process started with pid [995]</div>
<div class="line">[INFO] [rviz2-8]: process started with pid [997]</div>
<div class="line">[ERROR] [rviz2-8]: process has died [pid 997, exit code 127, cmd &#39;/opt/ros/humble/lib/rviz2/rviz2 -d /opt/ros/humble/share/turtle_tf2_py/rviz/turtle_rviz.rviz --ros-args -r __node:=rviz2&#39;].</div>
<div class="line">[rviz2-8] /opt/ros/humble/lib/rviz2/rviz2: error while loading shared libraries: libOgreMain.so.1.12.1: cannot open shared object file: No such file or directory</div>
<div class="line">[turtlesim_node-1] QStandardPaths: XDG_RUNTIME_DIR not set, defaulting to &#39;/tmp/runtime-docker&#39;</div>
<div class="line">[turtlesim_node-2] QStandardPaths: XDG_RUNTIME_DIR not set, defaulting to &#39;/tmp/runtime-docker&#39;</div>
<div class="line">[turtlesim_node-1] [INFO] [1694161886.877540952] [sim]: Starting turtlesim with node name /sim</div>
<div class="line">[turtlesim_node-2] [INFO] [1694161886.882499288] [turtlesim2.sim]: Starting turtlesim with node name /turtlesim2/sim</div>
<div class="line">[turtlesim_node-2] [INFO] [1694161886.887794726] [turtlesim2.sim]: Spawning turtle [turtle1] at x=[5.544445], y=[5.544445], theta=[0.000000]</div>
<div class="line">[turtlesim_node-1] [INFO] [1694161886.890579347] [sim]: Spawning turtle [turtle1] at x=[5.544445], y=[5.544445], theta=[0.000000]</div>
<div class="line">[turtlesim_node-1] [INFO] [1694161888.724143457] [sim]: Spawning turtle [turtle2] at x=[4.000000], y=[2.000000], theta=[0.000000]</div>
<div class="line">[turtle_tf2_listener-5] [INFO] [1694161889.716628642] [listener]: Successfully spawned turtle2</div>
</div><!-- fragment --><p> <img src="/ntu_racing_hw/ros2_setup/pictures/Screenshot%202023-09-08%20163053.png" alt="" class="inline"/></p>
<p>We can see that the rviz failed launching, it is because we didn't source the setup file first. Let's try again: </p><div class="fragment"><div class="line">docker@ros2:~/ws/src/launch_ws$ source install/setup.bash</div>
<div class="line">docker@ros2:~/ws/src/launch_ws$ ros2 launch launch_tutorial launch_turtlesim.launch.py</div>
<div class="line">[INFO] [launch]: All log files can be found below /home/docker/.ros/log/2023-09-08-16-34-58-646304-ros2-1128</div>
<div class="line">[INFO] [launch]: Default logging verbosity is set to INFO</div>
<div class="line">[INFO] [turtlesim_node-1]: process started with pid [1129]</div>
<div class="line">[INFO] [turtlesim_node-2]: process started with pid [1131]</div>
<div class="line">[INFO] [turtle_tf2_broadcaster-3]: process started with pid [1133]</div>
<div class="line">[INFO] [turtle_tf2_broadcaster-4]: process started with pid [1135]</div>
<div class="line">[INFO] [turtle_tf2_listener-5]: process started with pid [1137]</div>
<div class="line">[INFO] [mimic-6]: process started with pid [1139]</div>
<div class="line">[INFO] [fixed_frame_tf2_broadcaster-7]: process started with pid [1141]</div>
<div class="line">[INFO] [rviz2-8]: process started with pid [1143]</div>
<div class="line">[turtlesim_node-1] QStandardPaths: XDG_RUNTIME_DIR not set, defaulting to &#39;/tmp/runtime-docker&#39;</div>
<div class="line">[turtlesim_node-2] QStandardPaths: XDG_RUNTIME_DIR not set, defaulting to &#39;/tmp/runtime-docker&#39;</div>
<div class="line">[rviz2-8] QStandardPaths: XDG_RUNTIME_DIR not set, defaulting to &#39;/tmp/runtime-docker&#39;</div>
<div class="line">[turtlesim_node-2] [INFO] [1694162099.931566699] [turtlesim2.sim]: Starting turtlesim with node name /turtlesim2/sim</div>
<div class="line">[turtlesim_node-1] [INFO] [1694162099.933387109] [sim]: Starting turtlesim with node name /sim</div>
<div class="line">[turtlesim_node-1] [INFO] [1694162099.946094681] [sim]: Spawning turtle [turtle1] at x=[5.544445], y=[5.544445], theta=[0.000000]</div>
<div class="line">[turtlesim_node-2] [INFO] [1694162099.947224387] [turtlesim2.sim]: Spawning turtle [turtle1] at x=[5.544445], y=[5.544445], theta=[0.000000]</div>
<div class="line">[rviz2-8] [INFO] [1694162100.350545472] [rviz2]: Stereo is NOT SUPPORTED</div>
<div class="line">[rviz2-8] [INFO] [1694162100.350874073] [rviz2]: OpenGl version: 4.5 (GLSL 4.5)</div>
<div class="line">[rviz2-8] [INFO] [1694162100.491061667] [rviz2]: Stereo is NOT SUPPORTED</div>
<div class="line">[turtlesim_node-1] [INFO] [1694162101.868198567] [sim]: Spawning turtle [turtle2] at x=[4.000000], y=[2.000000], theta=[0.000000]</div>
<div class="line">[turtle_tf2_listener-5] [INFO] [1694162102.858944977] [listener]: Successfully spawned turtle2</div>
</div><!-- fragment --><p> <img src="/ntu_racing_hw/ros2_setup/pictures/Screenshot%202023-09-08%20163537.png" alt="" class="inline"/></p>
<h1><a class="anchor" id="autotoc_md176"></a>
That's all for the required parts of the ROS2 tutorials</h1>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
